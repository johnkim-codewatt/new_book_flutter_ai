<TODO 내용수정, 코드 검증 및 최적화 필요>

# 키를 활용한 상태관리
아래는 우리가 배운 목록형태의 ListView을 활용하는 예제이다. Apple, Banana, Cherry 라는 과일을 담은 평범한 형태의 과일 바구니가 있다고 가정해보자.

```dart
import 'package:flutter/material.dart';

main() {
  runApp(
    MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: Text('Fruit List')
        ),
        body: FruitApp(),
      ),
    ),
  );
}

class Fruit {
  final String name;
  Fruit(this.name);
}

class FruitApp extends StatefulWidget {
  @override
  State<FruitApp> createState() => _FruitAppState();
}

class _FruitAppState extends State<FruitApp> {
  //과일 바구니에 Apple, Banana, Cherry가 들어있다.
  List<Fruit> fruits = [Fruit('Apple'), Fruit('Banana'), Fruit('Cherry')];
  bool isSort = false; //리스트 정렬을 위한 플래그

  //과일 리스트를 반대로 정렬하기 위한 기능
  void toggleOrder() {
    setState(() {
      isSort = !isSort;
      fruits = fruits.reversed.toList(); //reversed 를 이용해서 과일들의 순서를 반대로 만든다.
    });
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        ElevatedButton( //버튼을 통해 과일리스트를 다시 정렬한다.
          onPressed: toggleOrder,
          child: Text(isSort ? '원래대로' : '반대로'), 
        ),

        Expanded(
          child: ListView( //리스트뷰를 통해 각각의 과일을 표시한다.
            children: fruits.map((fruit) => 
                FruitTile(fruit: fruit), //과일을 위한 하위 위젯 작성
              ).toList(),
          ),
        ),
      ],
    );
  }
}

class FruitTile extends StatefulWidget {
  final Fruit fruit;

  const FruitTile({super.key, required this.fruit});

  @override
  State<FruitTile> createState() => _FruitTileState();
}

class _FruitTileState extends State<FruitTile> {
  bool isFavorite = false;

  @override
  Widget build(BuildContext context) {
    return ListTile(
      title: Text(widget.fruit.name),
      trailing: IconButton(
        icon: Icon(
          isFavorite ? Icons.favorite : Icons.favorite_border,
          color: isFavorite ? Colors.red : Colors.grey,
        ),
        onPressed: () {
          //각 아이템을 클릭하고 해당과일의 상태를 변경합니다.
          setState(() {
            isFavorite = !isFavorite;
          });
        },
      ),
    );
  }
}

```

각각의 과일 이름으로된 FruitTile이 있고, 그 안에는 isFavorite 라는 상태를 가지고 있습니다. 만약 이 과일을 좋아하다면 버튼을 눌러 red로 color를 표시하기 위함 입니다. 여기까지는 잘 동작하며 별 문제가 없어 보입니다. 

![스크린샷 2025-06-21 오후 2.36.04.png](/images/03_10_키1.png)

그런데 자세히 살펴보면 상단에 배치된 버튼이 있습니다. 이버튼은 toggleOrder 함수가 실행되며, 리스트의 아이템들이 반전 되도록 만들어졌습니다. 실제로 동작시켜 보겠습니다.

```dart
ElevatedButton(
  onPressed: toggleOrder,
  child: Text(isSort ? '원래대로' : '반대로'),
),
```

![스크린샷 2025-06-21 오후 2.37.20.png](/images/03_10_키33.png)

반전 버튼을 눌렀더니 리스트의 아이템이 아래와 같이 반전되었습니다.

![스크린샷 2025-06-21 오후 2.37.03.png](/images/03_10_키2.png)

반전 기능은 잘 동작하는것 같지만, 문제가 있습니다. 분명히 Apple, Banana에 표시해둔 ‘좋아요’ 표시가 어째서 인지 Cherry, Banana에 붙어있습니다. 왜 이런일이 발생하는걸까요?

### **Flutter의 상태관리 방식**

원인은 Flutter의 상태관리방식에 있습니다. 하나씩 살펴보겠습니다.

우리가 순서변경을 위해 반전 버튼을 누르면, 이 버튼은 setState를 통해 build 함수를 다시 호출 하게됩니다. 즉 화면이 리빌드 되어지는 것이죠. 이때 우리가 만든 ListView 하위에 아이템인 FruitTile 역시 다시 생성되게 됩니다. 앞서 소개했듯이 Widget은 리빌드 시점에 매번 다시 생성되는 특징을 가지고 있습니다. 그렇기 때문에 State라고 하는 상태관리를 위한 특별한 객체를 가지고 있는 것이죠. 

**”Widget 은 언제든 다시 생성되기 때문에 이곳에 중요한 상태값을 넣어두면 안되겠죠?”**

Flutter는 언제든 다시 빌드되어지며, 그에 따라 Widget이 언제든 갱신되어 집니다. 이때문에 Flutter는 내부에 State를 보존하며, 이를 다시 재활용하기 위해 노력합니다. 새로 생성된 Widget과 이전에 가지고 있던 State 를 연결해주는 것이죠. 문제는 이때 발생합니다. 

```arduino
//flutter의 내부 소스
bool canUpdate(Widget oldWidget, Widget newWidget) {
  return oldWidget.runtimeType == newWidget.runtimeType &&
         oldWidget.key == newWidget.key;
}
```

우리가 보기엔 분명히 Cherry→Banana→Apple의 순서로 변경되었음에도 Flutter 입장에서는 다 똑같은 위젯일 뿐입니다. 기존에 가지고 있던 State와 새로 생긴 위젯을 맵핑하는 기준은 위젯의 타입과, Key 값입니다. 지금은 Key 값을 사용하지 않았으니 0번 index에 FruitTile 이라는 위젯이 만들어져있다면 아까 가지고 있던 0번 Apple이 가지고 있던 State를 그대로 0번에 맵핑시켜 버립니다. Apple, Banana, Cherry는 사용자가 목록아이템을 구분하는 값일 뿐입니다. Flutter입장에서는 아무상관이 없습니다. Flutter는 오직 index를 기준으로 해당 위젯타입을 새로 만든 위젯의 타입과 비교할뿐입니다. 때문에 이런 내부구조를 알아두지 않으면 문제가 발생했을때 해결하기가 쉽지 않습니다.

### **valuekey의 활용**

방법은 간단합니다. 위젯에 고유성을 부여하는것입니다. 즉 해당 위젯이 아까 그 위젯이 맞다는 표식을 남겨주는 것입니다. 이것을 우리는 key 라고 부르겠습니다.  key는 위젯과 상태를 매칭할때 이전과 같은 위젯이라는 일종의 힌트를 제공합니다. FruitTile 가 생성될때 ValueKey 라고 하는 Key 를 전달하고 다시 실행해 보겠습니다. valuekey는 말그대로 값을 활용한 Key값을 만드는 방법입니다. value은 변경되거나, 중복이 발생할수 있기때문에 주의가 필요합니다.

```dart
child: ListView(
  children: fruits.map(
    (fruit) => 
      FruitTile(
        key: ValueKey(fruit.name), //과일이름을 key값으로 전달
        fruit: fruit),
      ).toList(),
),
```

![스크린샷 2025-06-21 오후 4.04.39.png](/images/03_10_키3.png)

이제야 우리가 원하는대로 동작하기 시작합니다. 이렇게 위젯을 생성할때 key값을 사용하면 리빌드시에도 state를 매칭시켜 줍니다.

### key는 만능이 아니다

안타깝지만 key 값만으로는 우리가 예상한대로 상태가 유지되지 않는경우들이 많이 발생합니다. ListView가 아닌 ListView.Builder를 통해 화면을 구성해보겠습니다. 

```dart
 child: ListView.builder(
  itemCount: fruits.length,
  itemBuilder: (context, index) {
    return FruitTile(
      key: ValueKey(fruits[index].name),
      fruit: fruits[index],
    );
  },
),
```

![스크린샷 2025-06-21 오후 4.09.26.png](/images/03_10_키4.png)

![스크린샷 2025-06-21 오후 4.10.01.png](/images/03_10_키5.png)

ListView → ListView.Builder로 변경했을뿐인데 아까와 다르게 상태값이 꼬이기 시작합니다. 이는 ListView.Buidler의 특징 때문인데 내부적인 최적화와 위젯 재활용 등의 문제로 상태유지가 되지않는 문제가 발생합니다. 

>**“특정 상태가 여러 위젯에서 공유되거나, 스크롤 리스트처럼 위젯이 트리에 추가·제거되더라도 그 상태가 유지되어야 한다면, 그 상태를 더 상위(부모) 위젯에서 관리하는 것이 적절하다.”**
— [Managing state in Flutter]를 참조


즉 State는 100% 유지되는것이 아니기 때문에(내부구조에 따라 언제든 초기화발생가능) 특정 상황에서는 State객체가 아닌 트리구조의 상위객체, 외부구조에 의해서 관리하도록 권장되고 있습니다. 이것은 다음장인 상태관리 챕터에서 더 자세히 알아보겠습니다.

### 또다른 Key 종류

ValueKey이외에도 몇가지 key가 존재합니다. 

**GlobalKey**

`GlobalKey`는 다음과 같은 목적을 가지고 있습니다.

1. **고유한식별자**: 위젯 트리 내에서 위젯을 고유하게 식별합니다.
2. **상태접근**: 해당 위젯의 상태에 접근하거나 위젯의 위치를 찾을 수 있게 합니다.

위젯 트리구조상 상위위젯, 하위 위젯간 접근이 필요할때 유용합니다.

globalkey 를 생성하고 상위 위젯에 배치합니다. 아래의 _MyCounterWidgetState는 아직 만들어지지 않은 하위 위젯의 State입니다

```dart
class HomePage extends StatelessWidget {
  // 1. GlobalKey 생성
  final GlobalKey<_MyCounterWidgetState> _counterKey = GlobalKey<_MyCounterWidgetState>();
...
```

```dart
 // 2. MyCounterWidget에 GlobalKey 전달
 MyCounterWidget(key: _counterKey), // 하위 위젯에 전달
```

하위 위젯을 생성할때 globalkey를 전달 해줍니다. 

```dart
 // 3. 버튼으로 상태 조작
  ElevatedButton(
    onPressed: () {
      // GlobalKey를 사용하여 MyCounterWidget (하위 위젯) 의 상태에 접근하고 메서드를 호출
      _counterKey.currentState?.inputMsgUpToDown(10); //상위에서 값전달후 상태 갱신이 가능!
    },
    child: Text('Increment Counter'),
  ),
```

상위위젯에 있는 버튼을 눌렀을때 하위에 있는 함수를 실행하고 싶을지도 모릅니다. 생성자로 callback 함수를 전달하는 불편없이 쉽게 할수 있습니다.

**전체코드**

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: HomePage(),
    );
  }
}

class HomePage extends StatelessWidget {

  // 1. GlobalKey 생성
  final GlobalKey<_MyCounterWidgetState> _counterKey = GlobalKey<_MyCounterWidgetState>();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('GlobalKey Example'),
      ),
      body: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [

          // 2. MyCounterWidget에 GlobalKey 전달
          MyCounterWidget(key: _counterKey), // 하위 위젯에 전달
          SizedBox(height: 20),

          // 3. 버튼으로 상태 조작
          ElevatedButton(
            onPressed: () {
              // GlobalKey를 사용하여 MyCounterWidget (하위 위젯) 의 상태에 접근하고 메서드를 호출
              _counterKey.currentState?.inputMsgUpToDown(10); //상위에서 값전달후 상태 갱신이 가능!
            },
            child: Text('Increment Counter'),
          ),
          SizedBox(height: 20),
          ElevatedButton(
            onPressed: () {
              // Reset 버튼을 눌러 카운터를 초기화
              _counterKey.currentState?.resetCounter(); //이런식으로 하위에 직접 접근하여 갱신이 가능하다.
            },
            child: Text('Reset Counter'),
          ),
        ],
      ),
    );
  }
}

class MyCounterWidget extends StatefulWidget {
  MyCounterWidget({Key? key}) : super(key: key); //키를 받아서 가지고 있는다.

  @override
  _MyCounterWidgetState createState() => _MyCounterWidgetState();
}

// State 클래스 정의
class _MyCounterWidgetState extends State<MyCounterWidget> {
  int _counter = 0;

  // 카운터 증가 메서드
  void incrementCounter() {
    setState(() {
      _counter++;
    });
  }

  // 카운터 초기화 메서드
  void resetCounter() {
    setState(() {
      _counter = 0;
    });
  }

  void inputMsgUpToDown(int msg){

    setState(() {
      print("=== inputMsgUpToDown $msg ===");
    });
  }

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Text(
        'Counter: $_counter',
        style: TextStyle(fontSize: 24),
      ),
    );
  }
}

```
<br/>

**언제 어디서든 접근가능**
GlobalKey를 전역변수로 지정하면 트리 구조와 상관없이 언제 어디서든 접근이 가능합니다. 그야말로 글로벌한 활용방법 입니다.

```dart
import 'package:flutter/material.dart';

// GlobalKey를 선언하여 MyCustomWidget을 참조할 수 있게 합니다.
final GlobalKey<MyCustomWidgetState> myWidgetKey = GlobalKey<MyCustomWidgetState>();

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(title: Text('GlobalKey Example')),
        body: Column(
          children: [
            MyCustomWidget(key: myWidgetKey),
            ElevatedButton(
              onPressed: () {
                // 다른 위젯에서 GlobalKey를 통해 MyCustomWidget에 접근하여 메서드 호출
                // 그야말로 글로벌 키의 활용
                myWidgetKey.currentState?.changeText("Hello from another widget!");
              },
              child: OtherWidget(),
            ),
          ],
        ),
      ),
    );
  }
}

class MyCustomWidget extends StatefulWidget {
  MyCustomWidget({Key? key}) : super(key: key);

  @override
  MyCustomWidgetState createState() => MyCustomWidgetState();
}

class MyCustomWidgetState extends State<MyCustomWidget> {
  String displayText = "Initial Text";

  // 텍스트를 변경하는 메서드
  void changeText(String newText) {
    setState(() {
      displayText = newText;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Text(displayText, style: TextStyle(fontSize: 24)),
    );
  }
}

//전혀 다른 위젯이 -> 다른 위젯을 호출한다.
class OtherWidget extends StatelessWidget {
  const OtherWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return TextButton(
      onPressed: () {
        myWidgetKey.currentState?.changeText('다른 위젯에서 눌렀다!');
      },
      child: Text('누르시오'),
    );
  }
}

```

>Globalkey 의 의미를 오해하면 안됩니다. globalkey는 key를 공유하는 의미로 사용되면 안됩니다. 반드시 key는 Widget 별로 고유한 key를 생성하여 전달해야합니다.

---

**Objectkey**

ObjectKey는 객체의 참조를 이용해서 고유의 값을 생성하는 방법입니다. 말그대로 객체가 기준이며, 과일목록 예제에서는 아래와 같이 적용할수 있습니다.

```dart
 @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(title: Text('ObjectKey 예제')),
        body: ListView(
          children: fruits.map((fruit) => FruitTile(
            key: ObjectKey(fruit),
            fruit: fruit,
          )).toList(),
        ),
      ),
    );
  }
}
```

---

**Uniquekey**

Uniquekey 는 말그대로 유니크한 값을 자동으로 생성해서 고유한 key를 가지는 방법입니다. UniqueKey는 매번 완전히 새로운 고유 키가 생성되기 때문에 주의해야합니다.

```dart
@override
Widget build(BuildContext context) {
  return MaterialApp(
    home: Scaffold(
      appBar: AppBar(title: Text('UniqueKey 예제')),
      body: ListView(
        children: fruits.map((fruit) => FruitTile(
          key: UniqueKey(),
          fruit: fruit,
        )).toList(),
      ),
    ),
  );
}
```



---
### 참고자료
(https://docs.flutter.dev/data-and-backend/state-mgmt/simple)