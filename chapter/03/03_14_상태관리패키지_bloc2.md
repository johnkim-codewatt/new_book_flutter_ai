# Bloc 패키지 2
'Bloc' 패키지를 사용해서 상태관리를 하려면, 상당히 많은 클래스나 코드를 작성해야 하기 때문에 소규모 프로젝트에서는 오히려 독이 될수도 있다. 무작정 적용하기 보다는 팀원들의 지식 수준(설계, 최적화 등)을 고려해야하고 규모에 따라서 어떤게 득이 될지 항상 고민해야 하는 부분이다.

## cubit
cubit는 Bloc의 이러한 복잡도를 걷어낸 라이트한 버전의 상태관리 패턴이다. 기존의 '이벤트'기반의 처리방식에서 벗어나서 필요한 메서드를 직접 호출하는 방식이다.

아래의 예제를 살펴보자. 

```dart
class CounterCubit extends Cubit<int> { // Cubit 을 상속한다.
  CounterCubit() : super(0); // 초기값을 전달한다.

	// Bloc과 달리 메서드를 바로 호출한다.
  void increment() => emit(state + 1); // 상태 증가
  void decrement() => emit(state - 1); // 상태 감소
}
```

Bloc과 마찬가지로 상위에 지정할 BlocProvider를 등록하고

```dart
void main() {
  runApp(
    BlocProvider( //상위에 배치
      create: (context) => CounterCubit(), //Cubit을 추가한다.
      child: MyApp(),
    ),
  );
}
```

```dart
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: CounterScreen(),
    );
  }
}

class CounterScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    var count = context.read<CounterCubit>().state;

    return Scaffold(
      appBar: AppBar(
        title: Text('Cubit Example'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            
            Text(
              'Counter Value: $count',
              style: TextStyle(fontSize: 24),
            ),
            
            SizedBox(height: 20),
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                FloatingActionButton(
                  onPressed: () { //버튼이 눌렸을때
                    context.read<CounterCubit>().increment(); //'이벤트'가 아닌 메서드를 직접사용
                  },
                  tooltip: 'Increment',
                  child: Icon(Icons.add),
                ),
                SizedBox(width: 20),
                FloatingActionButton(
                  onPressed: () { //버튼이 눌렸을때
                    context.read<CounterCubit>().decrement(); //'이벤트'가 아닌 메서드를 직접사용
                  },
                  tooltip: 'Decrement',
                  child: Icon(Icons.remove),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}
```

위 코드를 보면 알수있듯이, Bloc처럼 복잡하거나, 장황하지 않고 간단하게 상태관리 및 로직처리에 대한 문제를 간단하게 처리할수 있다. 하지만 이 코드에는 약간의 문제가 있다. 버튼을 눌러도 아무일도 일어나지 않기 때문이다.

**BlocBuilder**
상태 변화에 따른 Text 위젯을 갱신하기 위해서 BlocBuilder 를 사용해보자. Provider를 익혔다면 providerBuilder 를 떠올리면 이해가 쉬울것이다. 기존에 사용되던 Text위젯을 BlocBuilder로 감싼후 제네릭 인자에 Cubit 타입과 상태타입을 작성한다.

```dart
 BlocBuilder<CounterCubit, int>(
    builder: (context, count) { //count 상태를 매개변수로 받아서 직접 사용할수 있다.
      return Text(
        'Counter Value: $count',
        style: TextStyle(fontSize: 24),
      );
    },
  ),
```

이제 버튼을 누르면, BlocBuilder로 감싼 Text위젯이 자동으로 갱신될것이다.

---

**BlocSelector**
BlocSelector은 기존 Provider의 Selector를 떠올리면 이해가 쉬울것이다. 이제는 다시 Bloc으로 돌아가서 예제 통해 살펴보자. CounterState에는 count, message 두개의 상태가 있고, BlocSelector를 사용하면 각각에 필요한 상태값을 구독처리할수있다.

```dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'counter_bloc.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

// 기본형식이 아닌 상태를 담당하는 모델 클래스
// 상태가 여러개 있음을 주목한다
class CounterState {
  final int count; //상태값1
  final String message; //상태값2

  CounterState({
    required this.count, 
    required this.message
  });
}

// 이벤트
abstract class CounterEvent {}
class IncrementEvent extends CounterEvent {}
class UpdateMessageEvent extends CounterEvent {
  final String newMessage;
  UpdateMessageEvent(this.newMessage);
}

// bloc 정의
class CounterBloc extends Bloc<CounterEvent, CounterState> {

  //CounterState를 생성하고 초기 상태를 전달한다
  CounterBloc() : super(CounterState(count: 0, message: "Initial Message")) {
    
    //이벤트 핸들러
    on<IncrementEvent>((event, emit) {
      emit( CounterState(count: state.count + 1, 
				      message: 'count값을 증가시킨다.') ); //count 상태만 모니터링 할수있다.
    });

    on<UpdateMessageEvent>((event, emit) {
      emit( CounterState(count: state.count, 
				      message: event.newMessage) ); //message 상태만 모니터링 할수있다.
    });
    
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: BlocProvider( // 상위에 배치
        create: (context) => CounterBloc(), // 작성한 bloc을 추가
        child: CounterScreen(),
      ),
    );
  }
}

class CounterScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('BlocSelector Example'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
          
            // BlocSelector를 사용해 CounterState의 count값만 구독처리한다.
            BlocSelector<CounterBloc, CounterState, int>(
              selector: (state) => state.count, //CounterState의 count값만을 구독처리 한다.
              builder: (context, count) { //count 값에 변화가 생기면
                return Text( //해당 위젯이 갱신처리된다.
                  'Counter Value: $count',
                  style: TextStyle(fontSize: 24),
                );
              },
            ),
            
            SizedBox(height: 20),
            ElevatedButton(
              onPressed: () {
	              // 카운터 증가 이벤트 추가
                context.read<CounterBloc>().add(IncrementEvent()); 
              },
              child: Text('Increment Counter'),
            ),
            ElevatedButton(
              onPressed: () {
	              // 메시지 업데이트 이벤트 추가
                context.read<CounterBloc>().add(UpdateMessageEvent("Updated Message!")); 
              },
              child: Text('Update Message'),
            ),
          ],
        ),
      ),
    );
  }
}

```

---

**MultiBlocProvider**
Provider에 MultiProvider가 있듯이, 여러개의 bloc을 관리해야 할 경우도 있을것이다.

```dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'counter_bloc.dart';
import 'message_bloc.dart';

//이벤트 1
abstract class CounterEvent {}
class IncrementEvent extends CounterEvent {}

//bloc 1
class CounterBloc extends Bloc<CounterEvent, int> {
  CounterBloc() : super(0) {
  
	  //이벤트 핸들러
    on<IncrementEvent>((event, emit) {
      emit(state + 1);
    });
    
  }
}

// 이벤트 2
abstract class MessageEvent {}
class UpdateMessageEvent extends MessageEvent {
  final String newMessage;
  UpdateMessageEvent(this.newMessage);
}

// bloc 2
class MessageBloc extends Bloc<MessageEvent, String> {
  MessageBloc() : super("Hello, World!") {
    on<UpdateMessageEvent>((event, emit) {
      emit(event.newMessage);
    });
  }
}

void main() {
  runApp(
    MultiBlocProvider(// 최상위에 배치
      providers: [
        //여러개의 bloc을 한번에 제공한다.
        BlocProvider<CounterBloc>(create: (context) => CounterBloc()),
        BlocProvider<MessageBloc>(create: (context) => MessageBloc()),
      ],
      child: MyApp(),
    ),
    
  );
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: CounterScreen(),
    );
  }
}

class CounterScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('MultiBlocProvider Example'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            
            // CounterBloc의 상태를 구독하여 카운터 값 표시
            BlocBuilder<CounterBloc, int>(
              builder: (context, count) {
                return Text('Counter Value: $count',
                  style: TextStyle(fontSize: 24),
                );
              },
            ),
            
            SizedBox(height: 20),
            
            ElevatedButton(
              onPressed: () {
                //상태값 증가 이벤트처리
                context.read<CounterBloc>().add(IncrementEvent());
              },
              child: Text('Increment Counter'),
            ),
            
            
            SizedBox(height: 40),
            
            // MessageBloc의 상태를 구독하여 메시지 표시
            BlocBuilder<MessageBloc, String>(
              builder: (context, message) {
                return Text(
                  'Message: $message',
                  style: TextStyle(fontSize: 24),
                );
              },
            ),
            
            
            SizedBox(height: 20),
            ElevatedButton(
              onPressed: () {
                context.read<MessageBloc>().add(UpdateMessageEvent("Updated at ${DateTime.now()}"));
              },
              child: Text('Update Message'),
            ),
          ],
        ),
      ),
    );
  }
}
```

---

## Copilot을 통해 실습해보세요
**Cubit 기본 구조 만들기**
Bloc보다 가벼운 상태관리인 Cubit을 통해
`상태 변경`, `메서드 호출`, `BlocBuilder`를 실습해보세요.

```dart
// 상태 타입은 int (숫자)
class CounterCubit extends Cubit<int> {//Cubit을 상속한다.
  CounterCubit() : super(0); // 초기값 0

  // 상태 증가 처리
  void increment() {
    //...
  }

  // 상태 감소 처리
  void decrement() {
    // ...
  }
}
```

```dart
// 앱 진입점에서 Cubit을 추가합니다.
void main() {
  runApp(
    BlocProvider(
      create: (_) => //...
      child: MyApp(),
    ),
  );
}
```

```dart
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(home: CounterPage());
  }
}
```

```dart
// 상태를 구독하고 화면을 갱신하는 페이지
class CounterPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Cubit 실습')),
      body: Center(
        //BlocBuilder를 사용해서 코드를 작성해보세요.
        child: //...
          builder: (context, count) {
            return Text(
              '값: $count',
              style: TextStyle(fontSize: 32),
            );
          },
        ),
      ),
      floatingActionButton: Row(
        mainAxisAlignment: MainAxisAlignment.end,
        children: [
          FloatingActionButton(
            onPressed: () {
              // 증가 메서드를 직접 호출
              context.read<CounterCubit>().increment();
            },
            child: Icon(Icons.add),
          ),
          SizedBox(width: 16),
          FloatingActionButton(
            onPressed: () {
              // 감소 메서드를 직접 호출
              context.read<CounterCubit>().decrement();
            },
            child: Icon(Icons.remove),
          ),
        ],
      ),
    );
  }
}
```