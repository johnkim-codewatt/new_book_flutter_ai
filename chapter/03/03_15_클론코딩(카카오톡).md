# Minitalk - 프로젝트

이번 챕터에서는 일명 '클론코딩'(앱을 모방하여 스터디에 활용)을 통해 앱에서 많이 사용하는 UI 구조와, 기능등을 유사하게 구현해보고, 이해를 돕는 시간을 가져보도록 하자.

- 완벽하게 카피하는것이 아닌 구조와 형식만 구현한다.
- Riverpod 기반 상태관리 + 로컬 mock(가짜) 데이터를 활용한다.
- 실습을 통해 상태 관리, UI 구성, 비동기 흐름, 리스트 렌더링을 익힐수 있다.

---

## **소개**
일상에서 자주 사용하는 ‘카카오톡’ 을 모방하는 연습용 앱을 작성해보자. 네트워크를 통한 기능구현은 포함되어 있지 않으며, 채팅 기능은 일종의 가상 데이터를 통해 시뮬레이션하는 방법으로 구현하도록 한다. 해당 챕터를 통해 앱 개발의 전체적인 구성과 흐름을 공부할수 있다. 

---

## **로그인과 가입**
현대의 앱에서 가입과 로그인인 기능은 필수적이다. 특히 최근에는 다양한 소셜 로그인 방식이 많이 활용되고 있다. 하지만 특정 소셜 로그인 기능을 구현하기에는 분량이 많고, SDK의 최신화 문제가 있기 때문에, 책 보다는 공식 문서를 보며 작업해야 한다고 판단했다. 본 챕터에서는 아이디/패스워드 처럼 기본형태를 가진 텍스트 입력을 통한 로그인 처리를 시뮬레이션 한다.

- **방식**: ID / Password 입력 → 더미 검증 (네트워크 없음)
- **검증 로직**: if (id == "test" && password == "1234") 형태의 단순 구조
- **화면 구성**: 로그인 화면 <-> 가입 화면 전환 가능

```dart
import 'package:flutter/material.dart';

void main() => runApp(const MinitalkApp());

class MinitalkApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Minitalk',
      home: LoginScreen()
    );
  }
}

// 아이디와 패스워드를 입력받는 간단한 화면이다.
class LoginScreen extends StatelessWidget {
  final TextEditingController idController = TextEditingController();
  final TextEditingController pwController = TextEditingController();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Minitalk 로그인')),
      body: Padding(
        padding: const EdgeInsets.all(20.0),
        child: Column(
          children: [
            TextField(
              controller: idController,
              decoration: InputDecoration(labelText: '아이디'),
            ),
            TextField(
              controller: pwController,
              decoration: InputDecoration(labelText: '비밀번호'),
              obscureText: true,
            ),
            SizedBox(height: 20),
            ElevatedButton(
              child: Text('로그인'),
              onPressed: () {
                checkValidIDPW(context);
              },
            ),
            TextButton(
              child: Text('회원가입'),
              onPressed: () {
                Navigator.pushNamed(context, '/register');
              },
            ),
          ],
        ),
      ),
    );
  }
  
  // 로그인 완료 처리를 위한 가상의 검증 테스트 이다.
  void checkValidIDPW(BuildContext context){
    final id = idController.text;
    final pw = pwController.text;

    // id 가 test이고, 비밀번호가 1234 일 경우 통과한다.
    if (id == 'test' && pw == '1234') {
      print('로그인 성공!');
    } else { //실패하면 dialog를 띄웁니다.
      showDialog(
        context: context,
        builder: (_) => AlertDialog(
          title: Text('로그인 실패'),
          content: Text('아이디 또는 비밀번호가 올바르지 않습니다.'),
        ),
      );
    }
  }
  
}

```

## 화면이동

로그인이 성공하면 앱의 홈페이지로 이동하도록 작성한다. 화면이동 처리를 위해 Route와 navigation을 활용해보자. initialRoute 으로 초기화면을 셋팅하고, routes로 필요한 경로를 설정한다.

```dart
void main() => runApp(MinitalkApp());

class MinitalkApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Minitalk',
      initialRoute: '/',
      routes: {
        '/': (_) => LoginScreen(),
        '/main': (_) => MainTabScreen(), // 다음 챕터에서 구현
      },
    );
  }
}
```

라우팅 설정을 마치고 로그인 성공시 홈으로 이동하기 위한 코드를 작성한다.

```dart

  //로그인 처리를 위한 검증 테스트 입니다.
  void checkValidIDPW(BuildContext context){
    final id = idController.text;
    final pw = pwController.text;
    
    //특정 정보가 맞다고 판단되면, 로그인 성공이다.
    if (id == 'test' && pw == '1234') {
      print('로그인 성공!');

      //로그인이 성공하면 main으로 이동하는 코드를 작성한다.
      Navigator.pushReplacementNamed(context, '/main');
    } else { //실패하면 dialog를 띄웁니다.
      showDialog(
        context: context,
        builder: (_) => AlertDialog(
          title: Text('로그인 실패'),
          content: Text('아이디 또는 비밀번호가 올바르지 않습니다.'),
        ),
      );
    }
  }
```

## 홈화면과 탭

이제 MainTabScreen() 을 작성하자. MainTabScreen은 세개의 화면으로 구성되며 탭 형식의 큰 틀안에 친구목록, 채팅목록, 설정페이지가 탭형식으로 포함된 형태이다. 각각의 화면은 파일로 구분되어 따로 작성한다.

```dart
import 'package:flutter/material.dart';

import 'friend_list_screen.dart';
import 'chat_list_screen.dart';
import 'settings_screen.dart';

class MainTabScreen extends StatefulWidget {
  const MainTabScreen({Key? key}) : super(key: key);

  @override
  State<MainTabScreen> createState() => _MainTabScreenState();
}

class _MainTabScreenState extends State<MainTabScreen> {
  int _currentIndex = 0; //현재 보여지고 있는 화면 기준

  // 탭별 화면 목록 (3개의 화면을 표시할 예정)
  final List<Widget> _screens = const [
    FriendListScreen(), //친구목록
    ChatListScreen(), //채팅목록
    SettingsScreen(), //설정페이지
  ];

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: _screens[_currentIndex], // 화면에 표시할 위젯을 가져온다.

      //bottomNavigationBar은 하단에 표시될 탭바를 의미한다.
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _currentIndex, //currentIndex 는 현재 표시될 화면 index를 대입합니다. 
        onTap: (index) {//탭 클릭시 해당 탭의 index를 currentIndex에 셋팅하고, 
          setState(() => _currentIndex = index); //setState를 통해 화면을 갱신합니다.
        },
        selectedItemColor: Colors.blue,
        unselectedItemColor: Colors.grey,
        items: const [
          BottomNavigationBarItem(icon: Icon(Icons.person), label: '친구'),
          BottomNavigationBarItem(icon: Icon(Icons.chat), label: '채팅'),
          BottomNavigationBarItem(icon: Icon(Icons.settings), label: '설정'),
        ],
      ),
    );
  }
}
```

코드로 이해가 잘 안된다면, 바로 실행시켜 보자. 단번에 이해가 될것이다. _currentIndex 변수는 현재 보고있는 페이지의 index를 표시하며, 이 숫자를 활용해 _screens[_currentIndex] 에서 필요한 화면을 read 할수 있다. BottomNavigationBar 는 하단탭 형식의 바를 제공하는 유용한 위젯이다.

FriendListScreen, ChatListScreen, SettingsScreen 에 해당하는 파일을 각각 작성한다. 일단은 기능은 추가하지 말고 우선은 단순한 화면 구조만 작성해보자.

```dart
// friend_list_screen.dart
import 'package:flutter/material.dart';

class FriendListScreen extends StatelessWidget {
  const FriendListScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('친구')),
      body: const Center(child: Text('친구 목록')),
    );
  }
}
```

```dart
// chat_list_screen.dart
import 'package:flutter/material.dart';

class ChatListScreen extends StatelessWidget {
  const ChatListScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('채팅')),
      body: const Center(child: Text('채팅 목록')),
    );
  }
}
```

```dart
// settings_screen.dart
import 'package:flutter/material.dart';

class SettingsScreen extends StatelessWidget {
  const SettingsScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('설정')),
      body: const Center(child: Text('설정 화면')),
    );
  }
}
```

---

## 친구목록작성
### FriendListScreen

이번에는 친구 목록 리스트를 디테일하게 구현해보자. 무작정 코딩을 시작하기 보다는 전체적인 디자인을 머릿속으로 그려보거나, 무슨 위젯을 어디에 배치할지 노트에 그려보는것도 좋은 방법이다. 그리고 나서 코딩을 시작하자.

***“카카오톡처럼, 프로필 사진 옆에 이름과 상태 메시지가 보이고, 누르면 친구의 상세 프로필이 열리면 좋겠어.”***

시작해보겠습니다. 우선 친구 목록에 표시할 각각의 ‘친구’ 에 해당하는 데이터가 필요하다. models 라는 폴더 아래에 Friend 라는 단일 친구 데이터를 가지는 클래스를 작성해보자.

```dart
lib/
├── data/
│   └── dummy_friends.dart     ← 더미 친구 목록
├── models/
│   └── friend.dart            ← Friend 클래스 정의
├── screens/
│   └── friend_list_screen.dart
├── main.dart
```

```dart
// 친구에 해당하는 데이터만을 가지고 있는 model
class Friend {
  final String name;
  final String statusMessage;
  final String profileUrl;

  Friend({
    required this.name,
    required this.statusMessage,
    required this.profileUrl,
  });
}
```

우리는 네트워크를 통해 데이터를 가져오지 않고 더미 데이터를 활용하기로 했다. 더미 데이터들은 따로 파일을 만들어서 관리하도록 한다.

```dart
import '../models/friend.dart';

final List<Friend> dummyFriends = [
  Friend(
    name: '홍길동',
    statusMessage: '안녕하세요 :)',
    profileUrl: 'https://i.pravatar.cc/150?img=3',
  ),
  Friend(
    name: '이순신',
    statusMessage: '밥은 먹고 다니냐',
    profileUrl: 'https://i.pravatar.cc/150?img=7',
  ),
  Friend(
    name: '강감찬',
    statusMessage: '오늘도 힘차게!',
    profileUrl: 'https://i.pravatar.cc/150?img=9',
  ),
];
```

이제 화면을 구현해보자.

```dart
import 'package:flutter/material.dart';
import '../data/dummy_friends.dart';
import 'friend_profile_screen.dart';

class FriendListScreen extends StatelessWidget {
  const FriendListScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('친구')),
      body: ListView.builder( //ListView.builder 로 데이터를 표시 한다.
        itemCount: dummyFriends.length,
        itemBuilder: (context, index) {
          final friend = dummyFriends[index]; //dummy 데이터를 활용해서 리스트를 채웁니다.
          return ListTile(
            leading: CircleAvatar( //동그란 형태의 사진 프로필
              backgroundImage: NetworkImage(friend.profileUrl),//NetworkImage는 url기반으로 자동으로 이미지를 표시합니다. 
            ),
            title: Text(friend.name, style: const TextStyle(fontWeight: FontWeight.bold)),
            subtitle: Text(friend.statusMessage, style: const TextStyle(color: Colors.grey)),
            onTap: () { //버튼을 눌렀을때는 FriendProfileScreen 프로필 화면으로 이동합니다.
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (_) => FriendProfileScreen(friend: friend),
                ),
              );
            },
          );
        },
      ),
    );
  }
}
```

 ListView.builder 를 통해 친구 목록을 표시하고 버튼을 눌렀을때 해당 친구의 프로필정보 화면으로 직접 이동되도록 라우팅을 처리하는 코드를 작성한다. 

---

## 친구프로필화면
### **FriendProfileScreen**

```dart
lib/
├── models/
│   └── friend.dart
├── screens/
│   └── friend_profile_screen.dart ← 이번에 작성할 파일
```

이번에는 친구의 프로필 상세 페이지를 작성해보자. (리스트에서 아이템을 선택하면 이동하는 그 화면이다.) 여기에 사진, 이름, 간단한 소개글 정도가 들어갈 예정이다. 

```dart
import 'package:flutter/material.dart';
import '../models/friend.dart';

class FriendProfileScreen extends StatelessWidget {
  final Friend friend;

  const FriendProfileScreen({super.key, required this.friend}); //생성자를 통해 friend를 전달받는다.

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('${friend.name}의 프로필')),

      //전달받은 friend 데이터를 활용해 화면에 표시한다.
      body: Padding(
        padding: const EdgeInsets.symmetric(vertical: 40.0, horizontal: 20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            CircleAvatar(
              radius: 60,
              backgroundImage: NetworkImage(friend.profileUrl),
            ),
            const SizedBox(height: 20),
            Text(
              friend.name,
              style: const TextStyle(fontSize: 22, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 10),
            Text(
              friend.statusMessage,
              style: const TextStyle(fontSize: 16, color: Colors.grey),
              textAlign: TextAlign.center,
            ),
            const Spacer(),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                child: const Text('채팅하기'),
                onPressed: () {
                  // 아직 채팅방 구현 전이므로 임시로 스낵바를 작성합니다.
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('채팅 기능은 아직 준비 중입니다.')),
                  );
                },
              ),
            )
          ],
        ),
      ),
    );
  }
}
```

여기서 주목할 부분은 이전 페이지에서 받아온 Friend 데이터이다. 여기에는 앱을 사용하는 유저가 클릭하는 순간에 정보 즉 어떤 친구의 프로필을 띄워야할지에 대한 정보가 담겨있다. 해당 친구의 정보를 가지고 프로필 사진, 이름, 자세한 소개를 표시할수 있다. 아직은 채팅기능을 수행할수 없기 때문에 임시로 ‘스낵바’ 형태의 메세지 바정도만 표시해두자.

---

## 채팅 목록 작성
이번에는 Minitalk의 핵심 기능인 채팅 기능과 관련된 내용을 작성 한다. 
우선 ChatRoom 이라고 하는 각각의 대화방에 해당하는 데이터 모델을 정의해보자. 여기에는 대화하는 친구 정보, 메세지, 등의 정보가 담겨있다.

```dart
//lib/models/chat_room.dart

import 'message.dart';
import 'friend.dart';

class ChatRoom {
  final Friend friend;
  final List<Message> messages;

  ChatRoom({
    required this.friend,
    required this.messages,
  });

  Message get lastMessage => messages.last;
}
```

서로의 대화내용을 저장하는 Message class를 작성합니다. 

```dart
//lib/models/message.dart
class Message {
  final String text; //메세지
  final DateTime timestamp; //시간
  final bool isMe; 

  Message({
    required this.text,
    required this.timestamp,
    required this.isMe,
  });
}
```

시간과 메세지, 대화에서 필요한 정보를 자유롭게 커스텀 하자. 데이터 구조가 완성되었다면, 이정도로 만들어두고 UI화면으로 넘어간다.


```dart
//lib/screens/chat_list_screen.dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

import '../data/dummy_chat_rooms.dart';
import 'chat_screen.dart';

// 채팅 목록을 표현하는 화면
class ChatListScreen extends StatelessWidget {
  const ChatListScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('채팅')),
      body: ListView.builder(// 기본은 리스트뷰이다.
        itemCount: dummyChatRooms.length,
        itemBuilder: (context, index) {
        
          final chatRoom = dummyChatRooms[index];
          final friend = chatRoom.friend;
          final last = chatRoom.lastMessage;

          return ListTile(
            leading: CircleAvatar(
              backgroundImage: NetworkImage(friend.profileUrl),
            ),
            title: Text(friend.name),
            subtitle: Text(last.text, maxLines: 1, overflow: TextOverflow.ellipsis),
            trailing: Text(DateFormat('HH:mm').format(last.timestamp)),
            onTap: () {
              Navigator.push( //해당 아이템을 탭하면 채팅창으로 이동한다. 
                context,
                MaterialPageRoute(
                  builder: (_) => ChatScreen(chatRoom: chatRoom),
                ),
              );
            },
          );
        },
      ),
    );
  }
}
```

이번에는 dummyChatRooms 라고 하는 필요한 가상의 데이터 구조를 작성해준다. 

```dart
import '../models/chat_room.dart';
import '../models/friend.dart';
import '../models/message.dart';

// ChatRoom 에서 사용할 가상의 데이터를 만든다고 생각하면 된다.
final dummyChatRooms = [
  ChatRoom(
    friend: Friend(
      name: '홍길동',
      statusMessage: '안녕하세요 :)',
      profileUrl: 'https://i.pravatar.cc/150?img=3',
    ),
    messages: [
      Message(text: '안녕?', timestamp: DateTime.now().subtract(Duration(minutes: 5)), isMe: false),
      Message(text: '잘 지내?', timestamp: DateTime.now().subtract(Duration(minutes: 2)), isMe: true),
    ],
  ),
  ChatRoom(
    friend: Friend(
      name: '이순신',
      statusMessage: '밥은 먹고 다니냐',
      profileUrl: 'https://i.pravatar.cc/150?img=7',
    ),
    messages: [
      Message(text: '오늘 회의 어땠어?', timestamp: DateTime.now().subtract(Duration(hours: 1)), isMe: false),
    ],
  ),
];
```

---

## 대화 상세 만들기
**ChatScreen**

```dart
lib/
├── screens/
│   └── chat_screen.dart ← 이번에 작성
├── widgets/
│   └── chat_bubble.dart ← 말풍선 UI 분리
```

대화 목록을 작성했으니, 다음은 대화방을 작성해보자. 카카오톡의 대화방을 떠올리시면 된다. 간단하게 상단에 친구정보를 표시하고 메세지는 말풍선 형태로 표시한다. 하단에는 텍스트 입력창과 입력 버튼을 만들면 된다. 

```dart
// lib/screens/chat_screen.dart

import 'package:flutter/material.dart';
import '../models/chat_room.dart';
import '../models/message.dart';
import '../widgets/chat_bubble.dart';

class ChatScreen extends StatefulWidget {
  final ChatRoom chatRoom; //해당 채팅방의 데이터를 가져온다.

  const ChatScreen({super.key, required this.chatRoom});

  @override
  State<ChatScreen> createState() => _ChatScreenState();
}

class _ChatScreenState extends State<ChatScreen> {
  final _controller = TextEditingController();
  final _scrollController = ScrollController();
  late List<Message> _messages;

  @override
  void initState() {
    super.initState();
    
    //필요한 가상의 데이터를 initState시점에 준비해둔다.
    _messages = List.from(widget.chatRoom.messages);
  }

  void _sendMessage() {
    //입력메세지를 가지고 온다.
    final text = _controller.text.trim();
    if (text.isEmpty) return;

    setState(() {
      //메세지 리스트에 이번에 입력한 메세지를 추가한다.
      _messages.add(Message(
        text: text,
        timestamp: DateTime.now(),
        isMe: true,
      ));
    });

    _controller.clear();
    
    Future.delayed(Duration(milliseconds: 100), () {
      _scrollController.jumpTo(_scrollController.position.maxScrollExtent);
    });
  }

  @override
  Widget build(BuildContext context) {
    final friend = widget.chatRoom.friend;

    return Scaffold(
      appBar: AppBar(
        title: Row( //상단에 표시할 친구 정보를 표시한다.
          children: [
            CircleAvatar(backgroundImage: NetworkImage(friend.profileUrl)),
            const SizedBox(width: 10),
            Text(friend.name),
          ],
        ),
      ),
      body: Column(
        children: [
          Expanded(
            child: ListView.builder( //대화 목록을 표시 한다.
              controller: _scrollController,
              itemCount: _messages.length,
              itemBuilder: (context, index) {
                final msg = _messages[index];
                return ChatBubble(text: msg.text, isMe: msg.isMe);
              },
            ),
          ),
          const Divider(height: 1),

          //메세지 입력을 위한 내용을 작성한다.
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8),
            child: Row(
              children: [
                Expanded(
                  child: TextField(
                    controller: _controller,
                    decoration: const InputDecoration(hintText: '메시지를 입력하세요'),
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.send),
                  onPressed: _sendMessage,
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}
```

TextEditingController 을 통해 Text 기반의 문자를 입력한다. 대화 내용은 _messages 에 저장되고 저장된 대화 내용은 setState를 통해 갱신처리된다. 이번에는 아직 작성하지 않은 ChatBubble 을 작성해보자. ChatBubble 에는 내가 말한 내용과 상대방의 대화를 구분하기 위해 isMe 라는 하나의 변수를 추가했다. 

```dart
import 'package:flutter/material.dart';

// 별다른것 없는 박스형태의 위젯이다.
class ChatBubble extends StatelessWidget {
  final String text; //생성자를 통해 텍스트를 전달 받는다.
  final bool isMe;

  const ChatBubble({super.key, required this.text, required this.isMe});

  @override
  Widget build(BuildContext context) {
    return Align(
      alignment: isMe ? Alignment.centerRight : Alignment.centerLeft,
      child: Container(
        padding: const EdgeInsets.all(10),
        margin: const EdgeInsets.symmetric(vertical: 4, horizontal: 8),
        decoration: BoxDecoration(
          color: isMe ? Colors.blue[100] : Colors.grey[200],
          borderRadius: BorderRadius.circular(12),
        ),
        child: Text(text), //전달받은 텍스트를 표시할뿐
      ),
    );
  }
}
```

ChatBubble 에서 Align 위젯을 사용해 isMe를 기준으로 좌, 우 정렬을 표현했다. 여기까지가 앱의 핵심 내용인 친구목록, 친구프로필, 대화목록, 대화 상세이다. 전체적으로 작성된 구조를 다시 한번 파악해보자.

```dart
lib/
├── main.dart                       // 앱 진입점
│
├── models/                         // 데이터 모델 정의
│   ├── friend.dart                // 친구 모델
│   ├── message.dart              // 메시지 모델
│   └── chat_room.dart           // 채팅방 모델
│
├── data/                           // 더미 데이터
│   ├── dummy_friends.dart        // 친구 더미 데이터
│   └── dummy_chat_rooms.dart     // 채팅방 더미 데이터
│
├── screens/                        // 주요 화면
│   ├── login_screen.dart         // 로그인
│   ├── register_screen.dart      // 회원가입
│   ├── main_tab_screen.dart      // 하단 탭 구조
│   ├── friend_list_screen.dart   // 친구 목록
│   ├── friend_profile_screen.dart// 친구 프로필
│   ├── chat_list_screen.dart     // 채팅 목록
│   └── chat_screen.dart          // 채팅방
│
├── widgets/                        // 재사용 위젯
│   └── chat_bubble.dart          // 말풍선 UI
```

폴더구조를 살펴보니 벌써 꽤 많은 코드가 만들어졌다. 핵심 기능들의 구성을 완료하였고, 개선해야할 점을 파악해보자. 사실상 개선해야할 부분을 따져보면 끝이 없기 때문에 필수적인 내용만 우선 체크해본다.

1. 이어서 작성할 settings.dart 에 로그아웃 기능을 추가한다. 
2. 화면 이동과 관련된 Route 셋팅을 개선할 필요가있다.
3. 상태관리는 특정 상태관리 패키지를 이용해서 리팩토링 해야한다.

---

## 설정 화면 만들기
**SettingsScreen**
셋팅 화면의 내용은 조금 자유롭게 작성해보자. 간단한 버전표시, 앱정보, 로그아웃 버튼 정도면 충분하다.

```dart
// lib/screens/settings_screen.dart
import 'package:flutter/material.dart';

class SettingsScreen extends StatelessWidget {
  const SettingsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('설정')),
      body: ListView(
        children: [
          const SizedBox(height: 20),

          const ListTile(
            leading: Icon(Icons.info_outline),
            title: Text('앱 버전'),
            subtitle: Text('v1.0.0'),
          ),

          const Divider(),

          ListTile(
            leading: const Icon(Icons.logout),
            title: const Text('로그아웃'),
            onTap: () {
              _confirmLogout(context);
            },
          ),

          const Divider(),

          const ListTile(
            leading: Icon(Icons.email_outlined),
            title: Text('문의하기'),
            subtitle: Text('contact@minitalk.app'),
          ),

          const Divider(),

          const ListTile(
            leading: Icon(Icons.person_outline),
            title: Text('개발자'),
            subtitle: Text('codewatt'),
          ),
        ],
      ),
    );
  }

  //로그아웃 처리를 시뮬레이션 한다.
  void _confirmLogout(BuildContext context) {
    showDialog(
      context: context,
      builder: (_) => AlertDialog(
        title: const Text('로그아웃'),
        content: const Text('로그아웃 하시겠습니까?'),
        actions: [
          TextButton(
            child: const Text('취소'),
            onPressed: () => Navigator.pop(context),
          ),
          TextButton(
            child: const Text('확인'),
            onPressed: () { //버튼에 따라서 화면 이동처리한다.
              Navigator.popUntil(context, ModalRoute.withName('/'));
            },
          ),
        ],
      ),
    );
  }
}
```


다소 심심한 화면이 만들어졌다. 옵션으로 다크모드와, 앱 푸시 스위치와 폰트사이즈를 추가해준다. 상태를 관리를 위해 각각의 변수를 추가한다.

```dart
bool _isDarkMode = false; //다크모드 on off
double _fontSize = 16; //폰트 사이즈
bool _pushEnabled = true; //push 전달 on off
```

기존 ListView의 child로 다크 모드 관련스위치를 추가한다. 

```dart
SwitchListTile(
  secondary: const Icon(Icons.dark_mode),
  title: const Text('다크모드'),
  value: _isDarkMode,
  onChanged: (value) {
    setState(() {
      _isDarkMode = value;
    });
    // 이후 전역 테마 적용 예정
  },
),

```

폰트 사이즈 관련도 추가한다.

```dart
ListTile(
  leading: const Icon(Icons.text_fields),
  title: const Text('폰트 크기'),
  subtitle: Text('${_fontSize.toInt()} pt'),
  trailing: Slider(
    min: 12,
    max: 24,
    value: _fontSize,
    onChanged: (value) {
      setState(() {
        _fontSize = value;
      });
    },
  ),
),
```

푸시 관련 내용을 추가합니다. (실제 푸시 발송기능과는 상관없다.)

```dart
 SwitchListTile(
	  secondary: const Icon(Icons.notifications_active),
	  title: const Text('푸시 알림'),
	  value: _pushEnabled,
	  onChanged: (value) {
	    setState(() {
	      _pushEnabled = value;
	    });
	    // 실제 알림 기능 연동 시 사용 예정
	  },
	),
```

코드가 분리되어있어서 이해가 어려울수 있을수 있다. 전체 코드를 살펴보고, 직접 코드를 작성하며 이해를 돕도록 한다.


**전체코드**
```dart
import 'package:flutter/material.dart';

class SettingsScreen extends StatefulWidget {
  const SettingsScreen({super.key});

  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> {
  bool _isDarkMode = false;
  double _fontSize = 16;
  bool _pushEnabled = true;

  void _confirmLogout(BuildContext context) {
    showDialog(
      context: context,
      builder: (_) => AlertDialog(
        title: const Text('로그아웃'),
        content: const Text('로그아웃 하시겠습니까?'),
        actions: [
          TextButton(
            child: const Text('취소'),
            onPressed: () => Navigator.pop(context),
          ),
          TextButton(
            child: const Text('확인'),
            onPressed: () {
              Navigator.popUntil(context, ModalRoute.withName('/'));
            },
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('설정')),
      body: ListView(
        children: [
          const SizedBox(height: 20),

          const ListTile(
            leading: Icon(Icons.info_outline),
            title: Text('앱 버전'),
            subtitle: Text('v1.0.0'),
          ),

          const Divider(),

          SwitchListTile(
            secondary: const Icon(Icons.dark_mode),
            title: const Text('다크모드'),
            value: _isDarkMode,
            onChanged: (value) {
              setState(() {
                _isDarkMode = value;
              });
              // 이후 전역 테마 적용 예정
            },
          ),

          ListTile(
            leading: const Icon(Icons.text_fields),
            title: const Text('폰트 크기'),
            subtitle: Text('${_fontSize.toInt()} pt'),
            trailing: Slider(
              min: 12,
              max: 24,
              value: _fontSize,
              onChanged: (value) {
                setState(() {
                  _fontSize = value;
                });
              },
            ),
          ),

          SwitchListTile(
            secondary: const Icon(Icons.notifications_active),
            title: const Text('푸시 알림'),
            value: _pushEnabled,
            onChanged: (value) {
              setState(() {
                _pushEnabled = value;
              });
              // 실제 알림 기능 연동 시 사용 예정
            },
          ),

          const Divider(),

          ListTile(
            leading: const Icon(Icons.logout),
            title: const Text('로그아웃'),
            onTap: () => _confirmLogout(context),
          ),

          const Divider(),

          const ListTile(
            leading: Icon(Icons.email_outlined),
            title: Text('문의하기'),
            subtitle: Text('contact@minitalk.app'),
          ),
          const ListTile(
            leading: Icon(Icons.person_outline),
            title: Text('개발자'),
            subtitle: Text('codewatt'),
          ),
        ],
      ),
    );
  }
}
```

---

## routing 개선

기존의 직접 하드코딩된 route 셋팅을 파일별로 분리해서 따로 관리하도록 해보자. 각각의 경로는 상수로 작성하고, 명확한 의미를 부여한다.

```dart
//상수를 통해 각각의 경로에 명확한 의미를 부여했다.
class RouteNames {
  static const String login = '/';
  static const String register = '/register';
  static const String main = '/main';
  static const String chat = '/chat';
}
```

```dart
import 'package:flutter/material.dart';
import '../screens/login_screen.dart';
import '../screens/register_screen.dart';
import '../screens/main_tab_screen.dart';
import '../screens/chat_screen.dart';
import '../models/chat_room.dart';
import 'route_names.dart';

// routing 처리를 공통으로 관리하기 위한 함수 작성
Route<dynamic>? generateRoute(RouteSettings settings) {
  switch (settings.name) {
    case RouteNames.login:
      return MaterialPageRoute(builder: (_) => const LoginScreen());

    case RouteNames.register:
      return MaterialPageRoute(builder: (_) => const RegisterScreen());

    case RouteNames.main:
      return MaterialPageRoute(builder: (_) => const MainTabScreen());

    case RouteNames.chat:
      final room = settings.arguments as ChatRoom;
      return MaterialPageRoute(builder: (_) => ChatScreen(chatRoom: room));

    default:
      return MaterialPageRoute(
        builder: (_) => const Scaffold(
          body: Center(child: Text('Page not found')),
        ),
      );
  }
}
```


```dart
import 'package:flutter/material.dart';
import 'routes/app_routes.dart';
import 'routes/route_names.dart';

void main() {
  runApp(const MinitalkApp());
}

class MinitalkApp extends StatelessWidget {
  const MinitalkApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Minitalk',
      initialRoute: RouteNames.login,//만들어준 상수 경로를 사용
      onGenerateRoute: generateRoute,//공통 라우팅 함수 사용
    );
  }
}
```


이제 경로를 직접 호출하지 않고 고정된 상수를 통해 경로 이동을 제어한다. 라우트를 따로 분리함으로써, 재사용이 가능하고, 유지보수가 쉬워졌다. 이후에 다른 화면이 추가되더라도 route_names.dart과 app_routes.dart만 수정하면 끝이다. UI 화면은 UI 의 역할에 충실하도록 하자.

---

## 리팩토링
기존에 작성된 코드는 외부의 패키지를 사용하지 않고 StateWidget, setState 를 통해 상태 관리를 했다. 때문에 필요없는 화면 갱신이 일어나거나, 상태관리에 불편한 점이 많다. 배운 내용을 토대로 RiverPod 또는 Bloc 을 활용해서 코드를 리팩토링 해보자.

