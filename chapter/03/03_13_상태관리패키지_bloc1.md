# Bloc 패키지
어떤 상태관리 패키지를 사용하든 첫 아이디어는 동일한 관점에서 출발한다. 바로 상위에 상태관리를 위한 무언가를 두고, 하위 위젯들이 이 상태에 접근하고 사용하도록 하는것이다. 이번에 소개할 Bloc 패키지도 최상단에 bloc 이라고 하는 상태관리 방법을 정의하고, 하위에서 이상태를 사용하는것이 목적중에 하나이다. 또한 bloc을 통해서, 코드를 작성하면, 자연스럽게 '클린' 한 코드에 가까워 진다.


### AI와 함께 학습하세요
>'클린아키텍처', '관심사의분리' 이와 같은 개념에 대해서 초보용자를 대상으로 비유를 들어 설명해줘.


## 스파게티코드
아래는 우리가 잘 사용하는 그런 흔한 코드이다. counter 상태와 각종 계산 함수들, UI 구현을 위한 각종 위젯들이 한곳에 모두 모여있다.

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(MaterialApp(home: MyPage()));
}

class MyPage extends StatefulWidget {
  @override
  _MyPageState createState() => _MyPageState();
}

class _MyPageState extends State<MyPage> {
  int counter = 0;

  //버튼을 눌렀을때 처리할 기능 구현
  void onPressed() {
    // 상태변경 + 비즈니스로직 + 조건판단 + UI 요소, 모든것이 모여있다.
    if (counter % 2 == 0) {
      counter += 3; // 짝수면 3을 더함
    } else {
      counter *= 2; // 홀수면 2를 곱함
    }

    // 조건 판단
    if (counter > 10) {
      
      //UI 출력
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('10을 넘었습니다!')),
      );
      counter = 0; // 초기화
    }

    setState(() {});
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('관심사 분리전혀 안됨')),
      body: Center(
        child: Text(
          '카운터: $counter',
          style: TextStyle(fontSize: 30),
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: onPressed,
        child: Icon(Icons.add),
      ),
    );
  }
}
```

**"그래서 이게 뭐가 어때서?"**
이런 코드는 간단한 구현을 할때 굉장히 편리하다. 하지만 우리의 업무 단위가 커지고 코드의 양이 수백, 수천라인이 넘어선다면, 어느새 편리했던 코드가, 불편한 코드가 되어있을것이다. 자연스럽게 서로가 서로에게 얽히고, 꼬일대로 꼬여서 부분적인 테스트 조차 불가능하게 만드는 그런 상황이 발생하게 된다. 당연히 분석하기도 어렵고 유지보수를 어렵게 만드는 원인이 된다. (처음배우는 입장이라면 전혀 이해가 가지 않을것이다.) 다시 말하자면 일회성 코드를 작성할게 아니라면 이런식의 ‘스파게티’ 소스를 작성하는 일을 지양하도록 하자.

### AI와 함께 학습하세요
>Q. 프로그래밍에서 말하는 일명 '스파게티' 코드가 대체 무엇인가요?

때문에 ‘관심사의분리’ 라는 거창한 타이틀 아래에, 우리는 각종 패키지를 사용하고, 복잡한 패턴들을 적용하여, 이 목표달성에 가까워 지려고 수많은 노력을 하는 것이다. 

예를 들어 보자. 우리가 회사에서 일을 한다고 가정해보자. 각 팀은 할일이 명확히 나누어져 있고, 서로의 업무에 대해 크게 관여하지 않는다. 각각의 팀, 부서는 자신의 일만 잘하면 그만인 상황이다. 바로 이것이다. 우리가 작성할 코드에서도 그대로 적용하면 된다.

개선을 위한 약간의 아이디어를 얻었으니, 코드에 적용해보자.

```dart
class CounterLogic { //CounterLogic 이라고 하는 상태 컨트롤러를 작성한다.
  int _counter = 0; //상태정보가 있고

  int get value => _counter;

  String onPressed() { //기능 구현도 되어있다.
    if (_counter % 2 == 0) {
      _counter += 3;
    } else {
      _counter *= 2;
    }

    if (_counter > 10) {
      _counter = 0;
      return '10을 넘었습니다!';
    }

    return '';
  }
}
```

이제 UI로 돌아와서 개선된 상태관리 방법을 적용해보자.


```dart
import 'package:flutter/material.dart';
import 'counter_logic.dart';

void main() => runApp(MaterialApp(home: MyPage()));

class MyPage extends StatefulWidget {
  @override
  _MyPageState createState() => _MyPageState();
}

class _MyPageState extends State<MyPage> {
  final logic = CounterLogic(); //상태,로직처리를 위한 클래스를 생성한다.

  //버튼이 눌렸을때 처리할 로직을 작성한다.
  void _handlePressed() {

    setState(() {
      //직접 처리하던 이전 방식과 다르게 로직처리를 CounterLogic에 위임했다. 따라서 결과만 받아서 화면에 표시하는데 집중한다.
      final result = logic.onPressed();
      if (result.isNotEmpty) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(result)),
        );
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('관심사 분리 ok')),
      body: Center(
        child: Text(
          '카운터: ${logic.value}',
          style: TextStyle(fontSize: 30),
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _handlePressed,
        child: Icon(Icons.add),
      ),
    );
  }
}
```

컨트롤러인 CounterLogic 클래스를 만들고 그안에서 상태 관련, 계산 로직을 처리하도록 작성했다. 이렇게 함으로써 CounterLogic 는 상태와 관련된 로직 처리에 집중하고, MyPage는 화면에만 집중하게 되었다. 따라서 테스트 가능성이 올라가고, 분석이 쉬워졌으며, 그에 따라 유지보수성이 올라갔다.

---

## **Bloc작성**
이제 이론을 탑재했으니, bloc패키지를 이해하는것이 한결 편안해질것이다. bloc은 크게 2가지로 파트로 분류할수 있다. UI와 Bloc이다. Bloc은 상태와 로직을 담당하고, UI작성과 관련된 작업을 전혀 알필요 없다. UI는 화면을 잘 보여주기 위한 동작만 잘하면 되고, 복잡한 계산식은 UI 담당파트 에서는 전혀 알 필요가 없는것이다.

**Bloc**
Bloc이라고 하는 일종의 컨트롤러는 상태관리와 비지니스로직을 처리하기 위해 존재한다. bloc 클래스를 작성할때는 Bloc 이라는 클래스를 extends하면 된다. 

```dart
// counter_bloc.dart
import 'package:flutter_bloc/flutter_bloc.dart';
import 'counter_event.dart';

//Bloc을 상속하고, 이벤트를 정의한 CounterEvent 를 추가한다.
class CounterBloc extends Bloc<CounterEvent, int> {
  CounterBloc() : super(0) {
    // 이벤트가 들어왔을 때 상태를 어떻게 바꿀지 정의
    on<Increment>((event, emit) => emit(state + 1));
    on<Decrement>((event, emit) => emit(state - 1));
  }
}
```

bloc은 기본적으로 이벤트 처리에 기반해서 동작한다. 위에서 작성한 'on<T>' 관련 코드가 바로 이것이다. 제네릭에 작성된 CounterEvent는 bloc으로 전달하는 Event 타입이며, int는 계산이 끝난후 전달하는 상태 타입을 의미한다.  

```dart
Bloc<CounterEvent, int>
```


**이벤트 작성**
Event는 우리가 자율적으로 작성하면 된다. 기본 데이터형을 전달해도 좋고, Event 타입을 세분화해서 관리해도 상관없다.

```dart
abstract class CounterEvent {}
class Increment extends CounterEvent {}
class Decrement extends CounterEvent {}
```

### AI와 함께 학습하세요
>Q. dart의 문법중에서 함수안에 함수를 작성하는게 가능한가? 

**상태 타입**
```dart
Bloc<CounterEvent, int>
```

제네릭에 두번째 인자인 int가 바로 상태타입이다. 간단한 처리는 기본형으로 충분하고 필요에 따라서 커스텀 클래스를 작성하면된다. 커스텀 상태 클래스를 작성하는것 또한 특별한 규칙이 없고, 아래와 같이 추가 하면 된다. 

```dart
Bloc<CounterEvent, CustomState>
```

**등록**
이제 bloc 과 관련된 코드작성이 완료 되었고, UI레벨에서 어떻게 접근해야할지 고민해보자. 앞서 상태관리와 관련된 대부분의 아이디어가 동일하다고 이야기 했다. 최상위에 상태관련을 배치하고, 하위 위젯들이 이 상태를 공유하는 형태가 그것이다. 

```dart
// 앱 시작
void main() {
  runApp(
    BlocProvider( //상태 제공을 위해 최상위에 배치한다.
      create: (_) => CounterBloc(), //앞서 만들어둔 CounterBloc을 추가한다.
      child: MaterialApp(home: CounterPage()),
    ),
  );
}
```

이제 하위 위젯에서 사용할때는 context를 사용하면된다.(build 메서드에서 전달받은) context를 통해 counterBloc 참조를 가져오는것 까지는 이해가 빠를것이다.

```dart
final bloc = context.read<CounterBloc>();
bloc.add(Increment());
```

다음 라인인 bloc.add는 조금 헷갈릴것이다. bloc은 기본적으로 이벤트 기반이라고 이야기 했다. 따라서 add 동작은 특정 이벤트를 추가해준다고 생각하면 이해가 쉽다. Increment 이벤트를 추가하면, bloc에 작성한 on<Increment>... 에 따라서 로직처리가 실행된다.

이제 화면에 표시할 상태값을 꺼내야 한다면, bloc 참조를 통해 CounterBloc의 state(int)를 가져올수 있다.

```dart
child: Text(
  '카운터: ${bloc.state}', //상태정보를 화면에 표시
  style: TextStyle(fontSize: 32),
),
```

**전체 코드**
전체코드를 살펴보면서 코드 흐름을 파악해보자. UI에서 버튼(on pressed)을 누르고 Event가 발생하고(add) 이 Event가 Bloc으로 전달된다. 전달된 Event에 따라서 필요한 로직이 처리되고(on 메서드) 마지막으로 int 값이 결과로 리턴된다. 리턴된 int값을 활용해 화면을 표시하는데 사용한다.

<TODO 흐름도 그림>

```dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

/// 이벤트 정의
abstract class CounterEvent {}
class Increment extends CounterEvent {}
class Decrement extends CounterEvent {}

/// Bloc 정의 (이벤트와 상태타입)
class CounterBloc extends Bloc<CounterEvent, int> {
  CounterBloc() : super(0) {
    //일종의 이벤트 맵퍼이다.
    on<Increment>((event, emit) => emit(state + 1));
    on<Decrement>((event, emit) => emit(state - 1));
  }
}

/// 앱 시작
void main() {
  runApp(
    BlocProvider(
      create: (_) => CounterBloc(),
      child: MaterialApp(home: CounterPage()),
    ),
  );
}

/// UI를 담당하는 하위 위젯을 작성한다.
class CounterPage extends StatefulWidget {
  @override
  State<CounterPage> createState() => _CounterPageState();
}

class _CounterPageState extends State<CounterPage> {
  int count = 0; //내부 상태정보
  final bloc = context.read<CounterBloc>();

  //이벤트 추가와 관련된 로직을 작성하는 메서드 작성
  void addIncEvent() {
    bloc.add(Increment()); //bloc에 증가 이벤트를 추가 한다.
  }

  void _addDecEvent() {
    bloc.add(Decrement()); //bloc에 감소 이벤트를 추가한다.
  }

  //화면과 관련된 부분을 처리하기 위한 메서드
  void getBlocState() async {
    // 직접 Bloc의 상태를 가져와 UI 갱신
    await Future.delayed(Duration(milliseconds: 100)); // 아주 잠깐 대기
    setState(() {
      count = bloc.state;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Bloc - 단순 예제')),
      body: Center(
        child: Text(
          '카운터: $count',
          style: TextStyle(fontSize: 32),
        ),
      ),
      floatingActionButton: Row(
        mainAxisAlignment: MainAxisAlignment.end,
        children: [
          FloatingActionButton(onPressed: addIncEvent, child: Icon(Icons.add)),
          SizedBox(width: 10),
          FloatingActionButton(onPressed: addDecEvent, child: Icon(Icons.remove)),
        ],
      ),
    );
  }
}
```

bloc을 통해 로직을 직접 수행하는것이 아닌, 이벤트 기반으로 처리를 위임하여 좀 더 유연한 코드를 작성하는 것이다. (이런 유연함이 결국 유지보수에 긍정적인 영향을 끼친다.)

### AI와 함께 학습하세요
>Q. dart의 bloc 패키지를 사용해보니, 코드가 오히려 복잡해지고 유지보수가 더 어려울것 같은데, 그냥 한 파일에 다 넣어 두고 주석으로 잘 설명하는게 좋을거같은데. 어떻게 생각해?

---

## **Copilot을 통해 실습해보세요 
**Bloc 기본 구조 구성**

아래 예제를 Copilot의 도움을 받아 완성해보세요.
Bloc 구조가 왜 필요한지, 관심사를 어떻게 분리하는지 체감할 수 있습니다.


```dart
// 다양한 이벤트 타입을 정의해보세요.
abstract class CounterEvent {}
// class Increment extends ...
// class Decrement extends ...
```

```dart
import 'package:flutter_bloc/flutter_bloc.dart';
import 'counter_event.dart';

// CounterBloc 클래스를 작성해보세요.
// Bloc<...> 를 상속받고, 
// 이벤트에 따라 로직을 처리하는 on<>() 메서드를 작성해보세요.

class CounterBloc extends //... {
  CounterBloc() : super(0) {
    // Copilot이 자동완성할 수 있도록 빈칸을 열어두세요.
    // on<Increment>((event, emit) => emit(state + 1));
    // on<Decrement>((event, emit) => emit(state - 1));
  }
}
```

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'counter_bloc.dart';

void main() {
  runApp(
    // BlocProvider로 CounterBloc을 앱에 공급해보세요.
    BlocProvider(
      create: (_) => //..., 
      child: MaterialApp(home: CounterPage()),
    ),
  );
}
```

```dart
class CounterPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final bloc = context.read<CounterBloc>();

    return Scaffold(
      appBar: AppBar(title: Text('Bloc 실습')),
      body: Center(
        // bloc.state 값을 화면에 출력해보세요.
        child: Text(
          '카운터: ${bloc.state}',
          style: TextStyle(fontSize: 32),
        ),
      ),
      floatingActionButton: Row(
        mainAxisAlignment: MainAxisAlignment.end,
        children: [
          FloatingActionButton(
            onPressed: () {
              // bloc.add()를 사용해서 Increment 이벤트를 보내보세요.
              //...
            },
            child: Icon(Icons.add),
          ),
          SizedBox(width: 10),
          FloatingActionButton(
            onPressed: () {
              // bloc.add()를 사용해서 Decrement 이벤트를 보내보세요.
              //...
            },
            child: Icon(Icons.remove),
          ),
        ],
      ),
    );
  }
}
```