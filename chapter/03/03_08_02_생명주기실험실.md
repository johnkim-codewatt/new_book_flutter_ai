# 생명주기 실험실

앞장에서 우리는 위젯의 생명주기(Lifecycle)에 대해 살펴보았다. 하지만 아무리 말로 듣고, 글로 읽어봐도, 한 번 실행해서 눈으로 확인하는 게 훨씬 더 강력한 학습방법이다. 이 장에서는 실제 코드를 통해 플러터에서 각 콜백 함수들이 언제, 어떤 순서로 호출되는지를 직접 확인해본다.(학습에 있어서 이해하기 어렵고, 복잡한 문제일수록, 일단 실행해보는것이 도움이 된다.)

**실험전에 알아두자**
1. StatefulWidget은 사실은 일종의 틀에 불과하다. State 객체가 실질적인 상태처리와 UI관련 처리를 담당한다.
2. 플러터 시스템은 성능 최적화를 위해 State 객체를 최대한 유지 하려는 특징을 가지고 있다. 이는 해당 위젯이 새로 생성 되더라도, 동일한 State 객체가 유지될 수 있다는 뜻이다.

아래의 코드를 살펴보자. 상위 위젯과, 하위 위젯들이 어떻게 관계되어 있는지 유심히 관찰해본다. 어떤 순서로 호출되는지 명확히  파악하기위해 각 생성자와 메서드는 로그를 출력하도록 작성되어있다.

**전체코드**
```dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MainApp());
}

//최상위 위젯
class MainApp extends StatelessWidget {
  const MainApp();

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
      body: MainStateWidget(100) //하위위젯 생성시 숫자 100을 전달한다.
      ),
    );
  }
}

//상위 위젯
class MainStateWidget extends StatefulWidget {

  // MainStateWidget 가 생성되고 로그를 출력한다.
  MainStateWidget(int message) {
    print("===MainStateWidget 생성자 $message===");
  }

  @override
  State<MainStateWidget> createState() { //언제 createState가 호출 되는지 궁금하지 않은가?
    print("===MainStateWidget createState===");
    return _MainState();
  }
}

//MainStateWidget 위젯의 State
class _MainState extends State<MainStateWidget> {
  @override
  void initState() { //initState는 언제 호출되는가?
    super.initState();
    print("===_MainState initState ===");
  }

  @override
  Widget build(BuildContext context) { //build는 자주 호출될수 있다.

    print("===_MainState build ===");
    
     return Column(children: [
      Text('Hello World!'),
      TextButton(
          onPressed: () => { //버튼을 누르고
            setState(() { // 화면을 갱신처리 해보자.
              print("=== _MainState 화면을 자체 갱신 합니다. ===");
            })
          },
          child: Text("상위 위젯에 있는 버튼")),
      SubStateWidget() //하위 위젯 생성
    ]);
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    print("===_MainState didChangeDependencies ===");
  }

  @override
  void didUpdateWidget(covariant StatefulWidget oldWidget) {
    super.didUpdateWidget(oldWidget);
    print("===_MainState didUpdateWidget ===");
  }
  
  @override
  void dispose(){
	  print("===_MainState dispose===");
  }
}
```

```dart
/**
 * 하위 위젯
 */
class SubStateWidget extends StatefulWidget {
  SubStateWidget() {
    print("=== SubStateWidget 생성자 ===");
  }

  @override
  State<SubStateWidget> createState() {
    print("=== SubStateWidget createState ===");
    return _SubState();
  }
}

class _SubState extends State<SubStateWidget> {
  @override
  void initState() {
    super.initState();
    print("===_SubState initState===");
  }

  @override
  Widget build(Object context) {
    print("===_SubState build===");

    return Container(
      color: Colors.amber,
      child: TextButton(
          onPressed: () => {
            setState(() => 
              print("===Sub State 자체적으로 갱신==="),
            )
          },
          child: Text("하위위젯버튼")),
    );
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    print("===_SubState didChangeDependencies===");
  }

  @override
  void didUpdateWidget(covariant StatefulWidget oldWidget) {
    super.didUpdateWidget(oldWidget);
    print("===_SubState didUpdateWidget===");
  }
  
  @override
  void dispose(){
	  print("===_SubState dispose===");
    super.dispose();
  }
}
```

---

### 시나리오 1 : 맨 처음 실행시
코드 작성이 끝났다면, 이제 실험해볼 차례이다. 코드를 실행하면 아래와 같은 출력 로그을 보게 된다.

```dart
flutter: ===MainStateWidget 상위 생성자===
flutter: ===MainStateWidget createState===
flutter: ===_MainState initState ===
flutter: ===_MainState didChangeDependencies ===
flutter: ===_MainState build ===

flutter: === SubStateWidget 생성자 ===
flutter: === SubStateWidget createState ===
flutter: ===_SubState initState===
flutter: ===_SubState didChangeDependencies===
flutter: ===_SubState build===
```

![스크린샷 2025-04-04 오후 9.41.52.png](/images/03_08_02_생명주기실험실_1.png)


번거롭지만, 출력된 로그를 보면 명확히 어떤 순서로 호출되었는지 알수있다.

**1. StatefulWidget 생성자**
```dart
MainStateWidget(int a) { ... }
```

가장 먼저 MainStateWidget 생성자가 호출된다. 이 시점에서는 아직 State는 생성되지 않은 상태이며, 단지 위젯 인스턴스를 만드는 단계이다.

**2. createState()**
```dart
State<T> createState() { ... }
```

해당 위젯이 자신의 상태(State)를 생성하기 위해 호출한다. 이때 실제로 State 객체가 메모리에 생성되며, 해당 위젯과 생성된 State가 연결된다.

**3. initState()**
```dart
void initState() { ... }
```

생성된 State 객체가 초기화되는 단계이다. 최초 1회만 호출되며, 주로 비동기 초기화, Controller 설정, 초기 데이터 세팅 등 초기화 관련 코드를 이곳에 작성하게된다.

**4. didChangeDependencies()**
```dart
void didChangeDependencies() { ... }
```

앞서 살펴본대로 didChangeDependencies는 아무때나 호출되지 않는다. 맨처음 호출된 이후로, InheritedWidget의 상태 관리 로직에 따라서 호출된다.

**5. build()**
```dart
Widget build(BuildContext context) { ... }
```

해당 위젯이 실제로 화면에 그려지는 시점이다. 반복적으로 호출될수 있기 때문에 이곳에서 초기화 코드를 작성하는 것에 주의해야한다.

(*SubStateWidget도 똑같은 구조로 진행된다.)

이 호출 구조를 머릿속에 넣어두면, 생명주기와 관련된 어떤 문제가 발생해도 빠르게 대처할 수 있게 된다.

---

### **시나리오 2: 하위 위젯 자체적으로 setState로 화면을 갱신할때**

이번엔 하위 위젯 내부에서 setState()를 직접 호출해보자. 이번에는 예상한대로 상위 위젯과는 상관없이, 하위 위젯에서만 build 메서드가 다시 호출 되었다.

```dart
flutter: === Sub State 자체적으로 갱신 ===
flutter: === build ===
```

---

### **시나리오 3: 상위 위젯의 State 가 자체적으로 setState 로 화면을 갱신할때**

이번에는 조금 흥미로운 일이 생긴다. 아래의 출력 로그를 살펴보자.

```dart
flutter: ===main 자체 갱신!===
flutter: ===_MainState build ===

flutter: === SubStateWidget 생성자 ===
flutter: ===_SubState didUpdateWidget===
flutter: ===_SubState build===
```

SubStateWidget이 상위 위젯의 setState() 호출로 인해 다시 생성되었다는 사실이다. 반면에 State와 관련된 호출 즉 createState, initState와 같은 메서드의 로그는 전혀 보이지 않는다. "어떻게 된 일인가?"

이것이 의미하는 바는 명확하다. 하위 위젯의 State 객체는 재생성되지 않고 그대로 '유지' 되었다는 것이다. 플러터는 위젯을 리빌드할 때 전체구조를 다시 생성하는 것이 아니라, 성능을 위해서 State 객체를 최대한 유지하려고 노력한다.

“자! SubStateWidget 위젯 자체는 새로 만들었어! 그렇지만 기존에 붙어있던 State 객체는 여전히 유효하니까, 그걸 다시 붙여줄게”

![image.png](/images/03_08_02_생명주기실험실_2.png)

이런 상황에서는 바로 didUpdateWidget() 메서드가 호출된다. SubStateWidget 위젯은 새로 바뀌었지만(생성됐지만), State는 그대로인 상황이다. 이 메서드를 통해 “어라, 새 위젯이 들어왔네?“ 라고 판단한뒤 필요한 작업을 수행하도록 코드를 작성한다. 이후에는 다시 build()가 호출된다.

---
