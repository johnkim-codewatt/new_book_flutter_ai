
# 다중상속

다트언어를 통해 상속을 구현할때는 단 하나의 부모만을 가져야한다. C, C++ 처럼 오래된 언어가 아니라면 현대 언어들은 대부분 단일상속만을 지원하고 있다. 다중상속의 경우 ‘다이아몬드 문제’ 처럼 심각한 문제들을 발생시키기 때문이다. 

그럼 아래의 예제를 통해 하나의 클래스가 둘 이상의 부모 클래스를 상속받을 때 발생하는 문제를 살펴보자. 

```dart
class Dog { //개의 종류, 부모클래스1
    void speak() {
			print("Dog 클래스 입니다.");
    }
}

class Bird { //새의 종류, 부모클래스2
    void speak() {
        print("Bird 클래스 입니다.");
    }
}

class NewAnimal extends Dog, Bird { //불가능, 다중상속은 지원하지 않는다.
    //...
}

main(){
	var animal = NewAnimal();
	animal.speak(); //어떤 부모의 speak 를 호출하지?
}
```

위의 예제에서 NewAnimal 클래스는 Dog와 Bird 클래스를 동시에 상속받는다.(가능하다는 가정) 그리고 나서 speak() 라는 함수를 호출하면 둘 다 해당 메서드를 가지고 있기 때문에 어느 메서드가 호출 될지 알수 없게 되는 문제가 발생한다. 이를 "다이아몬드 문제"라고 부르며, 단편적인 예이지만 이러한 모호성 증가의 문제 때문에 대부분의 객체지향 언어에서는 다중 상속을 지원하지 않는다. 또한 다중상속은 계층(부모, 자식과 같은)간의 복잡도를 더욱 증가시키며, 결과적으로 이는 수많은 버그와 오류를 초래할수 있다.

## 다중상속의 대안 mixin
그럼에도 불구하고 기존에 존재하는 수많은 클래스에 작성된 다양한 함수를 활용하고 싶다면, 다중상속과 유사한 방법이 필요할수도 있다. 그래서 Dart는 Mixin이라는 특수한 기능을 제공하고 있다. Mixin 은 상속처럼 부모 자식의 관계가 아닌 필요한 기능만을 가져다 쓸수 있는 유용한 방법이다.

Mixin을 사용하면 여러 클래스에서 사용할 유용한 기능을 정의할수 있다. Mixin은 클래스 계층 구조를 복잡하게 만들지 않고, 여러 클래스간에 필요한 공통 기능을 제공할 수 있게 특화된 방법이다.

```dart
mixin CanFly { // fly 기능을 정의하는 mixin
  void fly() { 
    print("날다");
  }
}

mixin CanSwim { // swim 기능을 정의하는 mixin
  void swim() {
    print("수영하다");
  }
}

//with 를 통해 필요한 기능을 가져온다.
class Duck with CanFly, CanSwim { //오리는 헤엄치고, 날기도 한다.
  void quack() { //Duck 고유의 기능
    print("꽥꽥!!");
  }
}

void main() {
  var duck = Duck(); //Duck을 만들고
  duck.fly(); //"날다" 를 사용할수 있다.
  duck.swim(); //"수영" 을 사용할수 있다.
  duck.quack(); // 오리 고유의 기능
}
```

Mixin을 사용하면 상속관계에 대한 부담없이 편리하게 기능을 추가하고 구현에만 집중할수 있다. 하지만 mixin은 기능 공유의 목적으로 밖에 사용할수 없기 때문에 결과적으로 활용도가 낮을수 밖에 없다.

```dart
void main() {
  // mixin으로 정의된 것은 단독으로 활용 할수 없다.
  CanFly(); // 인스턴스 생성 불가!
}
```

좀더 활용도를 높히기 위해 Dart 3.x 이후부터 mixin class 가 등장한다. mixin class 는 때로는 mixin 처럼, 때로는 class 처럼 사용할수 있기 때문에 Mixin보다 다양한 활용이 가능하다.

```dart
mixin class Logger{ //log 기능을 갖는 Logger
  //기록을 남기는 기능을 공유하고 싶다.
  void log(String message) {
    print('Log: $message');
  }
}
```

```dart
//필요한 기능만을 가져다 쓴다.
class FileManager with Logger { //with를 사용해 Mixin으로써 활용
  void saveFile() {
    //...
    log('파일저장완료!'); //mixin class에 있는 기능
  }
}

class NetworkManager with Logger {
  void sendRequest() {
    //...
    log('보내기성공!');
  }
}

void main() {
  var fileManager = FileManager();
  fileManager.saveFile();

  var networkManager = NetworkManager();
  networkManager.sendRequest();
}
```

이렇게 해서 Mixin의 원래 용도 대로 공유하고자 하는 기능을 정의하고 사용하기도하고, 필요할때는 extends 하여 부모 클래스로써 임무를 수행할수도 있다.

```dart
//상속하여 부모 자식 관계 형성
class FileManager extends Logger {
	//...
}

```

또한 class 를 인스턴스화 하여 단독 사용 하는것도 가능하다. 

```dart
main(){
	var logger = Logger();
	logger.log('안녕하세요.');
}
```


## 타입의 제한
mixin은 계층 구조에 얽매이지 않고, 여러 클래스에 기능을 재사용할 수 있는 유연한 구조이다. 하지만 아무 클래스에나 섞어 쓸 수 있기 때문에, 때로는 불필요하거나 위험한 조합이 생길 수도 있다. 예를 들어 사람(Person)에게만 적용해야 할 기능이, 기계(Machine)에도 사용되는 실수가 생긴다면 코드의 안정성과 의미가 무너지게 된다. 이런 상황을 막기 위해 Dart에서는 on키워드를 제공한다.

on키워드는 mixin이 특정 클래스타입(혹은 상위타입)에서만 사용 할수 있도록 제한을 설정하는 기능이다.

```dart
mixin Worker on Person { // Person 클래스를 상속한 클래스에서만 사용할 수 있는 mixin
  void work() {
    print('일하는 중입니다.');
  }
}
```

위 코드는 Worker는 Person을 상속한 클래스에서만 사용할 수 있다는 뜻이다. 즉, Person 타입이 아닌 클래스에서는 Worker의 기능을 사용할 수 없다. 무슨 이야기 인지 전체 코드를 살펴보자. 

```dart
class Person { // 사람 클래스
  void introduce() {
    print('안녕하세요. 사람입니다.');
  }
}

//on Person 제한을 걸었다. (Person을 상속한 클래스에서만 사용 가능)
mixin Worker on Person { 
  void work() {
    print('일하는사람 입니다.');
  }
}

// Employee 클래스는 Person을 상속했으므로 Worker 믹스인을 사용할 수 있다.
class Employee extends Person with Worker {
  //...
}

// CopyMachine 클래스는 Person을 상속하지 않으므로 Worker 믹스인을 사용할 수 없다.
class CopyMachine with Worker { //컴파일 오류 발생!
  void work() {
    print('카피머신 정상 작동중입니다.');
  }
}

void main() {
  var employee = Employee(); // Employee 객체 생성
  employee.introduce(); // 출력: 안녕하세요. 사람입니다.
  employee.work(); // 출력: 일하는사람 입니다.
  
  // CopyMachine 객체 생성은 불가능하다.
  var copyMachine = CopyMachine();
  copyMachine.work();
}

```

이처럼 on 키워드를 활용하면 특정 클래스 타입에만 사용할수 있도록 제한을 걸고, 코드의 안정성을 높힐수 있다.

## 기능확장 extension
Dart에는 extension 라는 키워드로 또 다른 기능구현 방법을 제공한다. extension을 사용하면 상속 관계 없이도 특정 클래스를 기반한 기능을 정의하고 사용 할수 있다. 

```dart
extension StringExtension on String { // String 클래스에 대한 확장 기능 정의
  String reverse() { // 문자열을 뒤집는 기능
    return split('').reversed.join('');
  }
}
```

위 코드는 기본 데이터 타입인 String 클래스에 StringExtension 이라는 확장 기능을 정의한 것이다. 이처럼 extension은 단독 사용이 아닌 기존에 만들어진 특정 클래스에 기반하여 작성한다. 정의된 StringExtension은 아래 처럼 사용하면 된다. 

```dart
void main() {
  String greeting = 'hello'; // String 타입의 변수 선언

  //마친 greeting에 reverse 함수가 있는것처럼 사용한다.
  print(greeting.reverse()); 
}
```

greeting 이라는 String 타입의 변수가 직접적으로 reverse 함수를 사용한걸 볼수 있다. 이는 reverse 라는 함수가 마치 String 본연의 내장 함수인것 처럼 사용되었다. extension 은 활용도가 좋기 때문에 다양하게 사용할수 있지만, 언제나 그렇듯이 극단적인 사용에는 문제가 발생할수 있다. extension 은 마치 특정 클래스 안에 해당 기능이 정의 된것처럼 보여지기 때문에 이 함수가 실제로 내장된 함수인지, extension인지, 대체 어디에 작성된 것인지 직접 확인해봐야 한다. (언제나 과용은 금물이다.)

### AI와 함께 학습하세요
>Q. 다중상속을 지원하는 언어와, 다중상속의 문제점에 대해서 설명해줘.


---

## Copilot 활용 실습

Dart에서는 클래스 간에 상속과 관계없이, 기능을 공유하고 싶을 때, mixin이라는 특수한 방법을 사용한다. 상속처럼 계층을 만들지 않고, 여러 클래스에 기능을 "섞어 넣을 수 있는" mixin을 직접 작성해보자.

```dart
// 1) 날 수 있는 능력을 가진 mixin 정의
mixin CanFly {
  void fly() {
    //...
  }
}

// 2) 소리를 낼 수 있는 mixin 정의
mixin CanMakeSound {
  void makeSound() {
    //...
  }
}

// 3) Bird 클래스는 날 수 있고, 소리를 낼 수 있습니다.
class Bird //... { //마치 필요한 기능을 가져다 조립하는 느낌!
  void info() {
    print('저는 새입니다.');
  }
}

void main() {
  var bird = Bird();
  bird.info();       // Bird 고유 기능
  // 각 mixin의 기능을 사용해보세요.
  //...

}
```