# 생성자



![생성자](../../images/02_16_생성자.png)



>“모든 것은 처음 만들어질 때가 가장 순수하다.” — 나심 탈레브



생성자는 무에서 유를 창조해내는 특수한 함수이다. 앞서 설명한 ‘틀' 로써 존재하는 클래스를 실체화 시켜주기 유일한 방법이기 때문이다. 이 ‘틀’을 바탕으로 진짜 사용할 수 있는 실체(객체)를 만들어주는 것이 바로 생성자의 역할이다.

```dart
class Car{ //우리는 클래스를 만들때 생성자함수를 만든적이 없다.
}
```

```dart
void main() {
  var car = Car(); // 하지만 호출할수 있다.
  print(car); // Car 인스턴스가 생성되었습니다.
}
```

Car()라는 생성자를 호출하면, 프로그램은 메모리 공간(*Heap 영역)에 새로운 객체를 만들어 car라는 변수에 할당한다. 즉, 껍데기 클래스(Car)에서 실제로 존재하는 ‘Car’ 를 만들어내는 유일한 방법이 생성자인 것이다. 그런데 위 예제 처럼 우리가 생성자를 직접 정의하지 않았음에도 사용할 수 있었던 이유는, Dart가 기본 생성자(default constructor) 를 암시적으로 자동 제공하기 때문이다. 이 기본 생성자는 매개변수가 없고, 아무 동작도 하지 않지만, 객체를 생성할 수 있도록 해준다.

### AI와 함께 학습하세요
>Q. 프로그래밍상에서 생성자를 호출한다는것은, 과연 내부적으로 무슨일이 일어나는 것인가? 실체를 만들어낸다는 것의 의미는 또 무엇인가? 초보자를 대상으로 쉽게 설명해줘.

**“그럼 이 생성자 함수를 우리가 만들수도 있지 않을까?”**

물론 Dart에서도 생성자를 직접 정의할 수 있다. 다만 Dart의 생성자 문법은 다른 언어와 조금 다르게 작동한다. 예를 들어 자바에서는 필요에 따라서 생성자를 다음과 같이 여러 개 정의할 수 있다.

```java
// 자바의 생성자 예시
public class Car {
		String brand;
    int year;

    // 생성자 1
    Car() {
      System.out.println("자동차가 생성되었습니다.");
    }
    
    // 파라미터를 받는 생성자 2
    Car(String brand, int year) {
		  System.out.println(year + "/" + brand + "자동차가 생성되었습니다.");
    
      this.brand = brand;
      this.year = year;
    }

    public static void main(String[] args) {
        Car car1 = new Car(); // 1번 생성자 호출
        Car car2 = new Car("Hyundai", 2023); // 2번 생성자 호출
      
    }
}

```

자바에서는 위처럼 생성자 이름은 모두 동일하게 Car()이지만, 매개변수의 종류나 개수에 따라 다르게 처리하는 ‘오버로딩(overloading)’이 가능하다.

>**[팁&노트]**
overloading(오버로딩)은 함수나 생성자의 이름은 같지만 매개변수의 개수나 타입을 달리해 여러 개 정의하는 기능이다. 자바나 C++ 같은 언어에서는 지원되지만, Dart는 오버로딩을 지원하지 않는다. 대신 선택 매개변수와 이름 있는 생성자를 통해 유사한 기능을 구현할 수 있다.

Dart에서는 비교적 간단하게 커스텀 생성자를 만들수 있다.

```dart
class Car{
  String? color;
  int? speed;

  // 커스텀 생성자를 만들었다.
  Car({this.color, this.speed});
}

main(){
  var car = Car(color: 'red', speed: 60); // 커스텀 생성자 호출
  print('색상: ${car.color}, 속도: ${car.speed}');
}

```

"앞에 java 코드와 무슨 차이가 있지?"라고 생각했을것이다. 예를 들어 아래 코드를 살펴 보자.

```dart
class Car{
  String? color;
  int? speed;
	
  // 생성자를 1개 만들었다.
  Car({this.color, this.speed}); 
  // 생성자를 2개 만들려고 시도
  Car({this.color}); //문제 발생 : 만들수 없다.
}
```

문제는 같은 이름으로 두번째 생성자를 만들때 발생한다. Java와 다르게 Dart는 같은 이름으로 생성자를 여러 개 만들 수 없다. (생성자 오버로딩을 허용하지 않기 때문이다.)

### 명명된 생성자
**"상황에 따라서 생성자가 여럿 필요한 경우도 있을텐데?"**<br>
Dart는 ‘이름 있는 생성자(named constructor)’를 사용해 여러 종류의 생성자를 정의할 수 있는 문법적 장치를 제공한다. 기본 생성자는 클래스명과 같은 이름을 사용하지만, 아래와 같이 생성자 이름에 점(.)을 붙여 별도의 이름을 부여할 수 있다.

```dart
class Car{
	String? color;
	int? speed;
	
	// 기본형 커스텀 생성자
	Car({this.color, this.speed}); 
	//Car({this.color}); // 더 만들수 없다. 클래스명을 가진 기본형 생성자는 하나만 생성가능!
	
	// 이름 있는 생성자방식 ok
  Car.second(){ //바디를 만들수 있고
    print('두번째 생성자 호출됨');
  }
  
  // '초기화목록' 방식을 활용한 이름 있는 생성자 ok
  Car.third(String color) : this(color); // 바디 없이도 ok
		
}
```

위 예제에서 보듯, 조금 특수한 방식으로 커스텀 생성자를 만들고 있다. 또한 Car.second() 와 Car.third(...)는 서로 다른 생성 방식과 초기화 방식을 가진 커스텀 생성자이다.

```dart
//호출 예제
void main(){
	var car = Car(color: "red", speed: 60);
  var car2 = Car.second();
  var car3 = Car.third("blue");
}
```

Dart 가 이런 방식을 채택한 이유는 이름있는 생성자를 통해 코드의 명확성을 전달하기 위함이다. 예를 들어 Car 클래스를 통해 다양한 차종의 생성을 도맡아 처리한다고 가정해보자.

```dart
class Car { // 차를 나타내는 클래스
  String type; // 차종을 나타내는 필드

  Car(this.type); // 생성시점에 차종을 전달받는다.
  Car.electric() : type = '전기차'; //생성시점에 type을 전기차로 초기화
  Car.hybrid() : type = '하이브리드'; // 생성시점에 type을 하이브리드로 초기화
}
```

아래 처럼 각각의 이름이 있는 생성자를 직접 호출하는것 만으로, 호출시점에 명확한 의미부여가 가능하게 된다.

```dart
void main(){
	var car1 = Car('가솔린');
	var car2 = Car.electric();
	var car3 = Car.hybrid();
}
```

---

## 추가로 알아두세요!

**생성자 초기화 목록**
생성자는 보통 { } 블록을 사용해 초기화 코드를 작성한다. 그러나 Dart에서는 : 콜론을 활용해 생성자 본문보다 먼저 값을 초기화할 수 있다. 이를 초기화 목록(initializer list)라고 부르며, 다음과 같이 사용한다.

```dart
class User {
  final String name;

  // 초기화 목록을 사용한 생성자
  User(String inputName) : name = inputName; // 초기화 시점에 name 필드를 자동으로 설정
}
```

이처럼 바디없는 생성자 함수의 구조가 처음에는 굉장히 어색하지만 이 표현방식은 Dart 공식 문서에서 권장하는 방법이다.

>**[팁&노트]**
초기화 목록은 생성자 본문이 실행되기 전에 인스턴스 변수들을 초기화할 수 있게 해준다. 이는 final 필드나 계산된 값을 초기화할 때 특히 유용합니다. [^1]

**부모 생성자를 호출할때**
상속에 대해서 아직 배우지 않았지만 간단하게 먼저 살펴 보겠습니다.(그냥 보는 것만으로 충분합니다.) 우리가 만든 Box 클래스가 있고, 다른 클래스를 상속(이와 같은 클래스를 부모클래스라고 한다.)하는 구조일때 해당 부모 클래스를 호출 해야 할경우가 있다.

```dart
Box(Object? value) : super(value); //super는 부모 클래스를 호출하는 참조자
```

 이럴때는 : (콜론) 을 통해 상위 생성자를 호출하면된다.

```dart
// 부모 클래스
class BaseBox {
  String value;
  BaseBox(this.value) {
    print('BaseBox 생성자가 호출되었습니다.');
  }
}

// 자식 클래스
class Box extends BaseBox {
  Box(String value) : super(value) {
    print('Box 생성자가 호출되었습니다.');
  }
}

void main() {
  Box("택배상자");
}
```

코드를 실행해보고 출력 결과를 확인해보면, 부모 클래스의 생성자가 먼저 호출되고, 그 다음에 자식 클래스의 생성자가 호출되는 것을 확인할 수 있다. 자연스럽게 super 키워드를 통해 부모 클래스의 생성자를 호출하는 구조를 이해할 수 있다. 아직 배우지 않은 상속에 관련된 부분이지만, 눈으로 익혀두도록 하자.


### AI와 함께 학습하세요
>Q. dart의 this와 super 키워드에 대해서 설명해줘.

---

## 심화학습
호출할때 기본 생성자처럼 보이는, 커스텀 생성자를 호출하는 예제이다. 실무에서 헷갈릴수 있기 때문에 주의가 필요하다. 만약 선택적 매개변수를 이용해 커스텀 생성자를 만들었다면 아래와 같이 작성할 수 있다.

```dart
//Car 생성자 작성
Car({this.color, this.speed}) { //{ } 를 이용해 선택형 매개변수를 정의
  print('Car 생성됨: color=$color, speed=$speed');
}
```

```dart
void main() {
  // 매개변수를 전달하지 않고 호출
  var car1 = Car(); // 이건 마치 기본 생성자처럼 보이지만...

  // 매개변수를 하나만 전달
  var car2 = Car(color: 'red');

  // 모든 매개변수 전달
  var car3 = Car(color: 'blue', speed: 120);
}
```

사실 같은 이름의 커스텀 생성자를 만들었다면, 원래 기본 형태의 생성자(인자값 없이)를 호출하려 해도 사실은 우리가 만든 커스텀 Car({this.color, this.speed})생성자가 호출되는 형태이다. 이런부분은 보이지 않는 내부 현상이기 때문에 알아두면 언제든 도움이 될수 있다. (내부적으로 null 을 대입한 커스텀 생성자가 호출되는것)

---

## Copilot 활용 실습

Dart에서 객체를 만들기 위해서는 ‘생성자’라는 특별한 함수가 필요하다. 아래 예제를 참고하여 클래스를 직접 정의하고 생성자를 만들고 호출해 보는 연습을 해보자. 과일 (Fruit) 클래스를 만들어서, 과일 이름과 가격을 저장하는 생성자를 작성해보자.

```dart
// Fruit 클래스 정의
class Fruit {
  // 1) 과일 이름과 가격을 저장할 변수 정의
  String name;
  int price;

  // 2) 생성자를 직접 정의해보자.
  // Fruit( ... )...

}

void main() {
  // 생성자를 호출해서 Fruit 객체를 만들어보자.
  // var fruit = Fruit(...);

  // 과일 정보를 출력
  // print('과일 이름: ${fruit.name}');
  // print('과일 가격: ${fruit.price}');
}
```

---
[^1] [Dart 공식 문서: Constructors](https://dart.dev/language/constructors) 