
# 동기와 비동기


![동기와 비동기](../../images/02_21_비동기처리.png)


>“모든 것은 제 시간이 되면 흘러간다.
중요한 건, 그 흐름을 방해하지 않는 것이다.” — 톨스토이



비동기 처리를 본격적으로 이해하려면, 먼저 동기(sync)와 비동기(async) 의 차이를 알아야 한다. 동기 방식이란 쉽게 말해 단일 흐름에 따른 순차 처리를 의미한다. 이런 방식은 이전 작업이 완전히 끝난 뒤에야 다음 작업을 시작하므로, 코드가 위에서 아래로 한 줄씩 순서대로 실행된다고 생각하면 된다. 동기 방식은 구현이 직관적이고 디버깅이 쉽다는 장점이 있다. 하지만 외부 I/O(네트워크 요청, 파일 읽기 등)작업이나 긴 계산 처리처럼 시간이 오래 걸리는 작업을 수행할때는 해당 작업이 완료될 때까지 전체 프로그램이 멈춰 버리는(블록되는) 치명적인 문제가 생긴다.

```dart
main(){ 
	var name = '홍길동';
	print('1번 작업'); // 1번작업 진행
	print(name); // 이름 출력
	print('2번 작업'); // 2번작업 진행
  print('3번 작업'); // 3번작업 진행
  //...
}
```

반면 비동기 방식은 작업을 “직접 수행하지 않고” 누군가에게 처리를 맡겨둔 후, 처리가 완료되는 시점에 그 결과를 받아 처리하는 방식이다. (엄밀히 말하면 Dart는 기본적으로 단일 스레드 모델이기 때문에 실제 내부 동작의 처리는 일반적인 멀티스레딩 처리와 다를수 있다.)

이런 방식을 논블로킹(non-blocking)방식이라고 부른다. 이건 마치 음료를 주문(음료 제조를 요청함)한 뒤 나는 테이블에 앉아서 책을 읽거나 스마트폰을 만지작 거리거나, 화장실을 가거나, 통화를 하다가, 음료 제조가 완료 되고 호출벨이 울리면 그제야 음료를 받으러 가는 상황과 비슷하다고 볼수 있다.

이제 위 상황을 코드를 통해서 구현해보자.

```dart
void main() {
  print('음료 가게에 도착함.'); // 가게 도착
  print('내가 음료를 주문함.'); // 음료 주문

  Future.delayed(Duration(seconds: 2), () { // 음료를 주문함. 약 2초뒤 음료가 완성된다.
    print('가게에서 음료를 제조가 완료되었습니다.');
  });

  print('나는 테이블에 앉아서 다른일을 한다.');
  print('앉아서 스마트폰을 본다.');
	print('잠시 화장실도 다녀온다.');
  //...
}
```

```dart
음료 가게에 도착함.
내가 음료를 주문함.
나는 테이블에 앉아서 다른일을 한다.
앉아서 스마트폰을 본다.
잠시 화장실도 다녀온다.
가게에서 음료를 제조가 완료되었습니다.
```

무슨 의미인지 잘 모르겠다면, 위 코드를 실행해보고 출력되는 순서를 확인해보면 단번에 이해가 될것이다. (음료 주문->제조에 대한 부분은 Future 라는 방법을 사용해 시간 지연을 시뮬레이션 처리 했다.) 만약 이것이 동기 방식이었다면, 내가 주문하고, 내가 만들고, 내가 가져다 먹는 형태가 될것이다.

***“비동기처리를 언제 어디서 써야 하나요?”***

지금은 "이걸 어디다 쓰지?" 라고 생각할수도 있다. 하지만 이후에 복잡한 상황을 구현하다보면 반드시 코드의 흐름을 ‘비동기적’ 으로 작성해야 하는 경우가 생긴다. 예를 들어 서버에서 데이터를 가져오는 경우이다. 서버와의 통신은 네트워크 지연이 필연적으로 발생한다. 만약 이런 상황을 동기 방식으로 처리한다면, 서버에서 데이터를 가져올 때까지 화면이 멈춰 있게 되고, 사용자는 멈춘 화면만 한참 동안 들여다 보게 된다.(가끔 스마트폰 앱을 사용하다보면 이런 상황들을 겪어 보았을것이다.) 또한 무거운 계산이나 복잡한 로직을 처리하기 위해 멀티스레딩 기법(타 언어에서)을 활용하는 경우도 이에 해당된다.

>**[팁&노트]**
Dart는 기본적으로 단일 스레드(single thread) 모델을 사용하고 있다. 비동기적으로 작업을 수행할수 있지만, 실제로는 동시에 실행되지 않는다. [^1]

---

## Future
우선 Dart에서 제공하는 대표적인 비동기 처리 방식인 Future부터 살펴보자. Future는 말 그대로 “미래의 값”을 의미한다.(dart의 문법은 굉장히 직관적인 편이다.) 지금은 값이 없지만, 나중에 생길 값을 약속(promise) 해주는 개념이다. 일종의 값이 약속된 데이터 홀더 라고 볼 수 있다. 이해를 돕기 위해 간단한 예제를 살펴 보자.

```dart
void main() {
  print('1번 작업');

  // 비동기 함수 호출, 결과가 도착하면 출력
  fetchName().then((name) {
    print('이름 출력: $name');
  });

  print('2번 작업');
}

// 2초 뒤에 '홍길동'을 반환하는 비동기 함수
Future<String> fetchName() { //Future 키워드를 활용한 함수
  return Future.delayed(Duration(seconds: 2), () => '홍길동'); //2초간 지연을 유발한다.
}
```

위 코드에서 fetchName()함수는 Future<String> 타입을 반환한다. 즉, 2초 뒤에 ‘홍길동’이라는 문자값을 제공하겠다는 의미이다. Future.delayed()는 일종의 지연된 결과를 시뮬레이션하는 기능이며, 2초뒤 then()블록이 실행된다.

```dart
1번 작업  
2번 작업  
이름 출력: 홍길동
```

잘 이해가 가지 않는다면, 일단 실행하고, 출력을 확인해보자. 1번 작업 → (이름 출력이 아닌) → 2번 작업이 진행된다. 이번에는 좀 더 복합적인 예를 들어보자. 

아래는 네트워크 통신을 시뮬레이션하는 코드이며 비동기 처리를 위해 여러겹으로 코드를 중첩하는 형태이다. (마찬가지로 실제 HTTP 요청 대신 Future.delayed()로 대체한다.)

```dart
void main() {
  print('앱 시작');
	print('작업 1');
	
  //서버에서 데이터를 가져온다.
	//중첩된 함수 호출1
  fetchUserData().then((user) {
    print('사용자 이름: $user');

    //호출 1이 끝나고 난 시점에
    //중첩된 함수 호출2
    fetchUserPosts(user).then((posts) {
      print('사용자 게시물: $posts');

      //호출 2가 끝나고 난 시점에
      //중첩된 함수 호출3
      fetchPostComments(posts[0]).then((comments) {
        print('첫 게시물의 댓글: $comments');
      });
    });
  });

	print('작업 2');
	print('작업 3');
  print('앱 종료');
}

// User 데이터를 가져오는 비동기 함수
Future<String> fetchUserData() async {
  await Future.delayed(Duration(seconds: 1));
  return '홍길동';
}

// User의 게시물을 가져오는 비동기 함수
Future<List<String>> fetchUserPosts(String user) async {
  await Future.delayed(Duration(seconds: 1));
  return ['게시물1', '게시물2'];
}

// 게시물의 댓글을 가져오는 비동기 함수
Future<List<String>> fetchPostComments(String post) async {
  await Future.delayed(Duration(seconds: 1));
  return ['좋아요!', '잘 봤어요~'];
}
```

위 코드는 한눈에 봐도 굉장히 복잡하고 이해하기 어렵다. 비동기적인 방식으로, 순차 처리를 진행 하기 위해 중첩된 then() 체인으로 처리하고 있다. 하지만 이 구조는 다음과 같은 문제점을 가지고 있다.

- 코드가 과도하게 중첩 되고(호출이 많아 질수록) 들여쓰기 깊어짐 (callback hell 과 유사)
- 비즈니스 로직, 흐름 파악이 매우 어려워짐
- 예외 처리(try/catch)가 어렵고 유지보수가 힘듦

개발자는 코드를 비동기적으로 처리를 해야 하지만, 순서는 보장 해야하는 모순적인 상황에 놓이게 된다.

## async + await

앞서 Future를 then()으로 연쇄 호출하면서 겪었던 문제들 (중첩 구조, 순서 보장 문제, 예외 처리의 어려움 등)은 실무에서도 자주 발생하는 문제이기도 하다. 이러한 불편함을 해결하기 위해 Dart에서는 async와 await라는 키워드를 제공하고 있다. async, await 구문은 js를 경험해봤다면, 익숙한 키워드일것이다. 개념적으로 유사하기 때문에 예제를 잠깐 살펴보자.


```dart
// 1초 뒤에 "완료!"를 반환하는 간단한 함수
function waitOneSecond() {
  return new Promise((resolve) => {
    setTimeout(() => resolve('완료!'), 1000);
  });
}

async function main() {
  console.log('시작');
  
  const result = await waitOneSecond();  // 1초 기다림
  console.log(result);                   // "완료!" 출력
  
  console.log('끝');
}

```

'async' 는 해당 블록이 비동기처리를 할 것이라는 의미를 부여한다. 그리고 나서 비동기적인, 순차처리가 필요한 부분에 await로 실행라인을 대기시키는 것이다. 다시 dart로 돌아와서 코드를 살펴보자. (마찬가지로 Future.delayed 부분이 서버를 통해 데이터를 가져오는 부분이라고 가정한다.)

```dart
main() async {//async로 main 함수가 비동기처리  블록임을 명시한다.
  print('1번 작업');
  //await 키워드를 사용하면 비동기적이면서도 순차처리의 흐름이 보장된다.
  await Future.delayed(Duration(seconds: 2)); // 2초 대기

  //1초 대기 후에 다음 라인이 실행
  print('2번 작업');
  await Future.delayed(Duration(seconds: 2)); // 2초 대기

  //1초 대기 후에 다음 라인이 실행
  print('3번 작업');
}
```

```dart
1번 작업
(2초 대기)
2번 작업
(2초 대기)
3번 작업
```

async 로 main 함수를 비동기 블록으로 지정하고, 대기가 필요한 라인에서 await 하면 비동기 처리도 동기식처럼 타이밍을 맞추어 로직을 구성할수 있게된다. 덕분에 코드 흐름을 동기적으로 짜듯 직관적으로 작성할 수 있다.

이제 앞에서 then() 체인으로 작성했던 API 호출 예제를 async/await로 다시 작성해보자.

```dart
// 1초 뒤에 '홍길동'을 반환하는 비동기 함수
Future<String> fetchUserData() async {
  await Future.delayed(Duration(seconds: 1));
  return '홍길동';
}

// 1초 뒤에 사용자 게시물을 반환하는 비동기 함수
Future<List<String>> fetchUserPosts(String user) async {
  await Future.delayed(Duration(seconds: 1));
  return ['게시물1', '게시물2'];
}

// 1초 뒤에 게시물의 댓글을 반환하는 비동기 함수
Future<List<String>> fetchPostComments(String post) async {
  await Future.delayed(Duration(seconds: 1));
  return ['좋아요!', '잘 봤어요~'];
}
```

async 로 비동기 블록을 만들고, 대기가 필요한 곳에 await 를 사용해 순차적인 흐름을 보장할수 있게된다.

```dart
// async/await를 사용한 깔끔한 비동기 처리
main() async {
  print('앱 시작');
  print('여러가지 작업 1');

  //await를 활용하면 코드의 실행 순서를 보장할수 있습니다.
  try {
    final user = await fetchUserData(); //1초 지연
    print('사용자 이름: $user');

    final posts = await fetchUserPosts(user); //1초 지연
    print('사용자 게시물: $posts');

    final comments = await fetchPostComments(posts[0]); //1초 지연
    print('첫 게시물의 댓글: $comments');
  } catch (e) { //exception 처리도 쉽게 가능
    print('에러 발생: $e');
  }

  print('여러가지 작업 2');
  print('여러가지 작업 3');
  print('앱 종료');
}
```



>**[팁&노트]**
대부분의 프로그래밍 언어는 try / catch 구조를 예외처리를 위한 구문으로 채택하고 있다. try 블록은 예외가 발생할 가능성이 있는 코드를 감싸고, catch 블록은 실제 에러가 발생했을 때 실행되는 코드를 작성한다. 



### AI와 함께 학습하세요
>Q. dart의 비동기처리를 공부중인데, async와 await를 언제 어떻게 사용해야 하는지 자세히 설명해줘.


---


## **Stream**
Future를 통해 단일 데이터를 위한 비동기 작업을 처리하는 방법을 배워보았다. 하지만 실제 개발을 하다 보면, 단 한 번만 값을 받아오는 것이 아니라, 계속해서 변화하는 데이터 흐름을 처리해야 하는 경우가 생긴다. 예를 들어 센서를 통해 초마다 데이터를 받아오거나, 채팅방에서 실시간으로 메시지를 수신하거나, 주식 가격을 실시간으로 갱신해야 경우 등이다. 이런 경우 Future 만으로 구현하기에는 한계가 있다.

아래의 예제를 살펴보자. 센서를 통해 1초 마다가 온도 데이터가 들어온다고 가정해본다.

```dart
// 센서를 통해 1초마다 온도값을 받아오는 상황을 Future로 구현할 때
Future<int> getTemperature() async {
  await Future.delayed(Duration(seconds: 1));
  return 25; // 임의의 온도 전달
}

void main() async {
  print('측정 시작');
  // 매번 수동적으로 온도를 읽어오는 구조
  for (int i = 0; i < 10; i++) { //10번 반복해서 온도를 측정한다.
    int temp = await getTemperature(); // 매번 Future를 기다림
    print('현재 온도: $temp°C'); // 온도 출력
  }
  print('측정 종료');
}
```

코드 실행에 별 문제가 없어보이지만, 매번 async await 호출이 필요하며(기다리고), 자동적인 처리 흐름이 아닌 수동으로 값을 계속 해서 읽어오는 구조이다. 

Future는 단 하나의 값만 처리하기 때문에, 매번 조건을 따지고, 함수를 반복 호출해야하는 상태이다. 이런 문제를 해결하기 위해 Dart에서는 Stream이라는 개념을 제공하고있다. 이름에서 느껴지듯, Stream은 데이터가 흐르는 통로이자, 마치 강물처럼 흘러오는 값들의 연속이라고 생각하면 된다. 헷갈릴 땐, 그 이름 그대로 “스트림(Stream)은 흐름을 처리할때 쓴다.”라고 기억하면 이해가 빠를것이다.

```dart
import 'dart:async';

void main() {
	//스트림을 통해 데이터를 생성한다.
  Stream<int> numberStream = Stream<int>.periodic(
    Duration(seconds: 1),// 1초마다
    (count) => count,// 숫자를 생성한다.
  ).take(5); // 5개의 숫자만 생성한다.
}

```

위 코드에서는 이해를 돕기 위해 Stream.periodic을 통해 1초마다 숫자(Stream<int>의 int 부분)를 하나씩 생성하며, take(5)를 추가해 5번만 값을 생성하도록 하였다. 하지만 이렇게 스트림을 만들었다고 해서 데이터가 바로 어디론가 흘러 가는건 아니다.

```dart
numberStream.listen((number) { //스트림을 구독한다.
  print('Number: $number');
})
```

위 코드는 listen() 함수를 통해 스트림을 구독하는 예시이다. 바로 이 시점부터 Stream은 활성화되고, 값이 흘러 가기 시작한다. 실행해 보면 다음과 같이 1초 간격으로 잘 출력되는것을 확인할수 있다.

```dart
print('Number: 1');
print('Number: 2');
print('Number: 3');
print('Number: 4');
print('Number: 5');
```

>**[팁&노트]**
단일 값이 아닌 Stream 같이 연속적인 흐름을 처리할 때는 listen() 을 통해 해당 스트림의 값을 가져오도록 코드를 작성하며, 이때부터 스트림이 활성화되고 값이 흘러가기 시작한다. 이를 구독(subscribe)한다고 표현한다. (유용한 정보가 들어있는 신문이 매일 배달된다고 생각해보자.) 따라서 우리는 한명의 구독자(subscriber)가 되는 것이다.


이제 연속적인 데이터의 흐름이 발생하고, 이를 구독하여 데이터를 사용하는 유연한 코드가 만들어졌다. 이제 위에서 Future로 작성된 센서 데이터의 흐름을 Stream 구조로 변경해 보자. 

```dart
import 'dart:async';

// 1초 마다 온도값을 생성하는 Stream
// async* 와 yield는 연속되는 값 발생을 시뮬레이션 하기 위해 추가
Stream<int> getTempStream() async* { 
  for (int i = 0; i < 10; i++) {
    await Future.delayed(Duration(seconds: 1));
    yield 25 + i; // 임의의 온도 변화를 연속적으로 방출
  }
}

void main() {
  print('측정 시작');
  // 스트림 구독: 온도가 들어올 때마다 자동으로 실행됨
  getTempStream().listen((temp) { // 구독 코드는 간결하다.
    print('현재 온도: $temp°C');
  }); 
}
```

```dart
측정 시작
현재 온도: 25°C
현재 온도: 26°C
현재 온도: 27°C
현재 온도: 28°C
현재 온도: 29°C
측정 종료
```

getTempStream 을 통해 Stream을 구독하면, 즉시 측정이 시작되고 1초마다 온도 데이터가 흘러들어오기 시작한다. 이 구조는 Future와 비교했을 때, 훨씬 간결하고 직관적이다. 또한 스트림은 여러 개의 값을 연속적으로 처리할 수 있기 때문에, 센서 데이터나 실시간 이벤트 처리에 매우 유용하다. 이해가 잘 안된다면, 우선은 내가 직접 값을 가져오는건지, 아니면 자동으로 값이 흘러들어오는지의 차이 부터 생각해보자.


>**[팁&노트]**
async*와 yield는 Stream 블록(데이터 흐름의 생성)을 직접 작성할 때 사용하는 키워드이다. async*는 비동기 + 스트림 함수임을 나타내며, yield는 값을 하나씩 스트림에 흘려보낼 때 사용된다.(return 을 떠올려보자) 즉, 여러 개의 데이터를 순차적으로 방출하고 싶을 때 return 대신 yield를 사용하면, 이를 통해 스트림 구독자가 연속적인 값을 받아서 처리할 수 있게 된다.


### StreamController

Stream은 데이터를 시간의 흐름에 따라 전달하는 통로이다. 하지만 실제 상황에서는 흐름을 시작하거나 멈추는등 제어하고 싶은 경우가 생긴다. 이때 사용하는 도구가 바로 StreamController 이다. StreamController는 우리가 직접 데이터를 흘려보내고, 구독자를 등록하고, 흐름을 닫을 수 있도록 해준다. 

아래의 코드를 살펴보자.

```dart
import 'dart:async';

void main() {
  // StreamController 생성
  final StreamController<int> controller = StreamController<int>();

  // controller.stream 를 통해 구독 (listener)
  controller.stream.listen((value) {
    print("Received: $value"); //데이터를 소비합니다.
  });

  // Stream에 데이터 추가하고, 이벤트를 발생 시킵니다.
  controller.add(10); // 스트림에 10을 추가 -> 구독자에게 전달
  controller.add(20); // 스트림에 20을 추가 -> 구독자에게 전달
  controller.add(30); //...

  // StreamController를 닫음
  controller.close();
}

```

StreamController를 사용하고, add()메서드를 통해 데이터를 직접 생성하고, 이 데이터는 스트림으로 구독자에게 흘려보낼 수 있게 된다. listen()을 통해 데이터흐름을 구독하고, 실시간으로 받아서 처리할 수 있다. 사용방법이 간결하고 편리하기 때문에, 이해하기 어렵지 않을것이다.

### AI와 함께 학습하세요
> dart의 비동기 처리 방식인 Future와 Stream은 각각 어떤 경우에 사용하는게 좋을까?

---

## **심화학습**
**다중구독자**
기본적으로 Dart의 Stream은 단일 구독자(single-subscription)만 허용한다. 즉, 하나의 구독자가 listen 하고 있으면, 두 번째 구독자는 구독할수 없다. 하지만 실무에서는 하나의 데이터 흐름을 여러 구독자가 동시에 듣는 상황이 많이 발생한다. 이런 경우에는 StreamController.broadcast()를 사용하여 다중 구독이 가능한 스트림을 만들어야 한다.

```dart
void main() {
	//스트림 컨트롤러를 통해 broadcast 를 생성한다.
  StreamController<String> controller =       StreamController<String>.broadcast(); // broadcast()를 사용하여 다중 구독이 가능한 스트림을 생성한다.

	//어디선가 구독자1이 구독하고
  controller.stream.listen((data) { //구독자 1
    print('Listener 1: $data');
  });

	//또 다른 구독자들, 여러명이 구독해도 문제가 없다.
  controller.stream.listen((data) { //구독자 2
    print('Listener 2: $data');
  });

  controller.add('Hello'); //데이터를 추가(흘려보낸다) -> 구독자들에게 전달된다.
  controller.add('World');

  controller.close(); //더 이상 필요 없다면 반드시 close 해야한다.
}

```

예제에서는 두 명의 구독자가 동시에 동일한 데이터를 수신하고 있다. 이처럼 StreamController.broadcast() 를 활용하면 몇 명의 구독자가 있던 Stream을 통해 정보를 유연하게 전달 할수 있다.

### **필요없다면 닫아준다**
코드를 자세히 보면, controller.close() 라는 처음보는 코드라인이 있을 것이다. close()는 StreamController의 스트림을 명시적으로 종료할 때 사용하는 메서드이다. 비유하자면, 마치 수도꼭지를 잠그는 동작과 같다고 생각하자. 더 이상 물(데이터)이 흐르지 않도록 통로(Stream)를 닫는 것이다.

```dart
controller.close();
```

**“왜 close() 가 필요할까요?”**
우리가 수도꼭지를 왜 잠가야 하는것과 똑같은 이유이다. 1차적으로는 자원의 누수를 방지하기 위함이다. Stream이 열린 상태로 남아 있으면 메모리, CPU 등 자원을 계속 점유할 수도 있기 때문이다. 또한 불필요한 호출을 막는 역할도 한다. 누군가, 혹은 코드상 어딘가에서 더이상 사용하지 않는 Stream에 add를 시도하거나, listen을 시도한다고 생각해보자. 이런 상황은 예기치 않은 동작을 유발할 수 있다. 따라서 더 이상 사용하지 않는 StreamController는 반드시 close()를 호출하여 명시적으로 종료해주는 것이 좋다.

### **연속적인 데이터를 발생시키는 방법**
앞서 잠깐 살펴봤듯이 연속적인 데이터 흐름을 생성하는 또 다른 방식은 async* 함수와 yield 키워드를 사용하는 것이다. 이 구조는 스트림(Stream)을 직접 만들어내는 데에 사용된다. (우리가 배웠던 async 키워드에 * 을 추가해주면 된다.)

아래 코드를 살펴보겠습니다.

```dart
Stream<int> numberGenerator() async* { // async* 키워드를 사용하여 스트림을 생성

  // 1초마다 1부터 5까지의 숫자를 생성
  for (int i = 1; i <= 5; i++) {
    await Future.delayed(Duration(seconds: 1)); // 1초 지연
    yield i; // 값을 스트림을 통해 하나씩 흘려보냄
  }
}

void main() {
  var numStream = numberGenerator(); //스트림을 가져와서
  numStream.listen((num) { // 구독한다.
    print('=== 숫자 생성 중... $num ==='); //구독하면 값이 들어오기 시작한다.
  });
}
```

위 예제코드를 하나씩 살펴보자. 우선 async에 * 을 붙혀 비동기스트림 블록임을 명시했다. for 반복문을 통해 1초마다 숫자를 하나씩 만들어내는 구조를 만들고, await를 통해 1초 마다 데이터 생성을 가정했으며, 단일 값을 전달하는 return대신 yield를 사용해서 연속적으로 값을 외부에 전달하는 역할을 추가했다. 이처럼 Stream, async*, await, yield가 조합되면, 시간에 따라 변화하는 데이터 흐름을 자연스럽게 구성할 수 있다. 외부에서는 listen()을 통해 이 메서드(스트림)을 구독하고, 값이 도착할 때마다 수행할 작업을 처리할 수 있다.

---

## Copilot 활용 실습

Copilot을 활용하여 비동기 처리의 Future와 Stream을 연습해보자. 아래의 코드를 따라 작성하면서, 비동기 처리의 흐름을 이해하고, Copilot이 제안하는 코드를 활용해보자.

```dart
// 1) 2초 뒤에 문자열을 반환하는 Future 함수를 작성해보자.
Future<String> fetchMessage() async {
  // Copilot을 통해 코드를 완성하고 문자열 값을 반환하는 코드를 작성한다.
  //await Future.delayed(Duration(seconds: 2));
  //return ...;
}

// 2) 위의 Future를 호출하고 then()으로 결과를 출력하는 코드를 작성해보자.
void getFutureMessage() {
  print('1. 메시지를 요청합니다');
  // fetchMessage() 를 호출하고, then()을 사용하여 결과를 출력하는 코드를 작성한다.
  // fetchMessage().then((msg) {
    //...
  //});

  print('2. 다른 작업 수행 중'); // 메시지를 요청한 후 다른 작업을 수행합니다.
  print('3. 다른 작업 수행 중');
  print('4. 다른 작업 수행 중');
  //...

}

// 3) Stream 블록을 만들어 1초마다 숫자를 5번 보내는 코드를 작성해보자.
// async*, await, yield 키워드를 사용합니다.
Stream<int> numberStream() async* {
  for (int i = 1; i <= 5; i++) {
    await Future.delayed(Duration(seconds: 1));
    yield //...
  }
}

// 4) 위의 Stream을 listen()으로 구독하고 데이터를 출력하는 코드를 작성해보자.
void getNumberStream() {
  print('숫자 스트림 시작');
	//numberStream()를 호출하고, listen()을 사용하여 구독한다.
  //numberStream().listen((value) {
  //print('→ 수신된 값: $value');
  //});
}

// 5) main 함수에서 위의 두 함수를 호출해보자.
void main() {
  getFutureMessage(); // Future 메시지 요청
  getNumberStream(); // 숫자 스트림 시작
}
```


---


[^1] Dart 공식 문서 — Concurrency in Dart : https://dart.dev/language/concurrency