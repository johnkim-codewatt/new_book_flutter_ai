# 다형성

만약 우리가 만든 프로그램에서 동물들이 점점 늘어난다면, 일일이 동물마다 dog.breathe(), cat.breathe() 를 호출하는 것도 번거로워 질것이다. 그래서 우리는 다음처럼 부모 타입인 Animal 을 매개변수로 받아서 처리하는 함수를 만들 수 있다.

```dart
// 부모 클래스 Animal 정의
class Animal {
  void makeSound() {
    print('동물이 소리를 냅니다...');
  }
}

class Dog extends Animal {
  @override
  void makeSound() {
    print('멍멍!');
  }
}

class Cat extends Animal {
  @override
  void makeSound() {
    print('야옹!');
  }
}
```


```dart
class AnimalSound {
  void makeSound(Animal animal) { // Animal 타입을 매개변수로 받는다
    //animal은 dog 일수도, cat 일수도 있다.
    //정확히 뭔지는 모르지만 해당하는 makeSound 를 호출한다.
    animal.makeSound();
  }
}
```

```dart
void main() {
  var animalSound = AnimalSound(); // 편의를 위해 만들어진 AnimalSound
  var dog = Dog(); // Dog를 생성한다.
  var cat = Cat(); // Cat을 생성한다.

  animalSound.makeSound(dog); // 내부적으로 dog.makeSound()가 호출된다.
  animalSound.makeSound(cat); // 내부적으로 cat.makeSound()가 호출된다.
}
```

편의를 위해 만들어진 AnimalSound.makeSound() 함수는 호출시 dog도 넣고 cat도 넣을수 있다. 즉 Animal을 상속한 클래스라면 어떤 객체든 이 함수에 넣을 수 있다는 말이다. 각 동물들의 고유한 기능을 직접 호출 하지 않고, 호출을 대리자에게 위임하는 유연한 방법이다.

**“어떻게 이런게 가능한가요?”**
코드 자체는 간단해 보이지만 이 안에는 상속(부모, 자식), 업,다운캐스팅의 개념, 이를 통한 다형성 이라는 복합적인 개념이 포함되어있다.

## 업캐스팅과 다운캐스팅
예를 들어 Animal을 extends한 Dog는 자동으로 계층 관계가 만들어진다. 자연스럽게 Animal이 부모 타입이 되고, Dog가 서브타입이 되는것이다.

![image.png](attachment:b4b8cc4e-7586-4b1e-a1a2-0e454e3a046f:image.png)

이와 같이 형성된 부모-자식 관계는 아래의 코드처럼 변경할수도 있다. 

```dart
Dog dog = Dog();
Animal dog = dog as Animal;
```

dog를 as 라는 키워드를 통해 상위 타입인 Animal로 직접 캐스팅을 할수도 있다. 이를 업캐스팅 이라고 부르며, 결국 이 코드는 하위 타입인 Dog가 상위 타입인 Animal로 어디든 쓰여질수 있다는 의미가 된다. 

상위 타입으로 업캐스팅 하는 방법인 as Animal는 사실상 필요없는 코드이다.(문법의 이해를 돕기위해 작성) 왜냐하면 하위->상위 타입으로 암시적인(보이지 않지만) 자동 캐스팅이 일어나기 때문이다. (as Animal 생략하는 것이 일반적이고 가독성에도 좋다.)

```dart
Animal dog = dog; //as Animal을 생략해도 OK
```

좀 더 과정을 생략해서 아래처럼 상위 타입의 형태(모습)로 하위 타입 객체를 직접 생성 할수도 있다.

```dart
Animal animal = Dog();
```

animal 은 우리가 알기로는 분명 Dog이지만(Dog로 생성했으니), 겉보기에는 Animal 타입으로 보이기 때문에, 만약 아래와 같이 dog 타입으로 활용하고 싶다면, 강제적 캐스팅을 해야한다. 이를 다운 캐스팅 이라고 부른다. 

```dart
Animal animal = Dog(); // Dog를 상위 타입으로 작성
Dog dog = animal as Dog; // 다시 하위 타입으로 강제 캐스팅
```

다운 캐스팅을 할때 주의해야 할점은 다운 캐스팅 하려는 animal 객체가 하위 타입인 Dog 이라는 명확한 보증이 될때에만 사용해야 한다. 강제로 캐스팅 하는 방법이기 때문에 경우에 따라 전혀 다른 타입을 잘못 캐스팅 하는 일이 생길수도 있다.

```dart
Animal animal = Cat(); // Cat도 Animal이니까 업캐스팅은 언제나 ok
//Dog인줄 알고 animal을 다운캐스팅
Dog wrongDog = animal as Dog; // 여기서 오류 발생!
```

"에이 이런일이 언제 생겨" 라고 할수도 있지만, 의외로 타입 캐스팅 오류는 굉장히 흔하게 발생한다. 따라서 필요한 경우 아래와 같이 is 키워드를 활용한 타입 체크 로직을 구현하는것도 좋은 방법중 하나이다.

```dart
if(animalDog is Dog){ // animalDog 가 Dog 인지 검증한다.
	print('Dog타입으로 캐스팅을 해도 안전하다.');
}else{
	print('Dog타입으로 캐스팅이 불가능합니다.');
}
```

이처럼 상속에 의한 계층 관계가 형성되면 상위타입, 하위타입간의 자유로운 형변환이 일어나기 때문에 항상 주의해서 코드를 작성해야한다. 

### AI와 함께 학습하세요
>Q. dart에서 extends(상속)을 통해 만들어진 부모, 자식 관계에 대해서 초보자를 대상으로 쉽게 설명해줘.


---

## **다형성(Polymorphism) – 다양한 형태로 동작한다**

다형성(Polymorphism) 이란 단어는 처음 들으면 조금 어렵게 느껴질 수 있다. 하지만 개념 자체는 우리가 일상에서도 늘 쓰고 있는 방식이다. 예를 들어 보자.

“운전하다” 라는 행위를 자동차, 오토바이, 전기 킥보드가 각각 수행한다고 해봅시다. 모두 ‘운전’이라는 같은 행동을 하지만, 자동차는 핸들을 돌리고 가속 패달을 밟고, 오토바이는 스로틀과 몸의 밸런스를 이용해서, 전기 킥보드는 스로틀과, 몸의 균형감각으로 운전합니다. 이것들은 사실 다 다르게 작동하고 세부적인 운전방법이 전부 다르다. 하지만 우리는 이걸 통칭해서 운전하다(Drive) 라고 부를수 있다. 이것을 프로그램 세계에 가져와 보겠습니다. 

```dart
// 운전이라는 공통 동작을 정의한 부모 클래스
class Vehicle {
  void drive(){//통칭 운전하다.
    print('운전하다.');
  } 
}
```

이 Vehicle 클래스는 각각의 Car, Motorcycle, Kickboard 와 같은 서브 클래스에서 상속되며, 각각에 맞는 다른 기능들을 구현하게 된다.

```dart
// 각기 다른 방식으로 drive()를 구현한 클래스들
class Car extends Vehicle {
  @override 
  void drive() {
    print('자동차: 핸들을 돌려 운전합니다.');
  }
}

class Motorcycle extends Vehicle {
  @override
  void drive() {
    print('오토바이: 스로틀과 몸의 밸런스로 운전합니다.');
  }
}

class Kickboard extends Vehicle {
  @override
  void drive() {
    print('전기 킥보드: 스로틀만 돌리고, 서서 운전합니다.');
  }
}
```

마지막으로 호출코드를 작성하고 실행해보겠습니다.

```dart
// 다양한 형태의 Vehicle을 운전하다.
void testDrive(Vehicle vehicle) {//Vehicle 타입으로 전달 받는다.
  vehicle.drive(); // drive를 호출한다.
}

void main() {
  var car = Car();
  var motorcycle = Motorcycle();
  var kickboard = Kickboard();

  testDrive(car);         // 자동차: 핸들을 돌려 운전합니다.
  testDrive(motorcycle);  // 오토바이: 스로틀과 몸의 밸런스로 운전합니다.
  testDrive(kickboard);   // 전기 킥보드: 스로틀만 돌려 운전합니다.
}
```

우리는 편의를 위한 testDrive()라는 함수를 만들었고, 이 함수를 통해 어떤 Vehicle 이든 drive 하도록 실행코드를 작성한다. 여기서 중요한 것은 Vehicle이라는 공통 부모 클래스를 함수의 매개변수로 받아들이고 있다는 것이다. 이렇게 작성된 testDrive 함수는 자동차든 오토바이든, 전기 킥보드든 다 넣을 수 있게 되고, 매개변수로 받은 vehicle을 통해 각각의 운전하다를 실행하게 된다. 다시말해 testDrive에서는 vehicle이 뭐든간에 (car, motorcycle, kickboard) 그저 drive를 실행할 뿐이다.

```dart
vehicle.drive();
```

이 처럼 같은 형태(Vehicle)로 다른 기능(각각의 기능)을 수행하는것” 그게 바로 “다형성” 이라는 개념이다.


### AI와 함께 학습하세요
>Q. 객체지향프로그래밍에서 상속과 다형성 대해서 공부중이야.다형성에 대해서 비유를 들어서 자세하게 설명해줘.

---

## Copilot 활용 실습

실제로 객체지향과 관련된 개념은 처음에는 단번에 이해하기 어렵다. 다형성, 업/다운캐스팅, override 등 상속에서 자주 쓰이는 핵심 기능들을 직접 실습해보며 이해를 돕도록 하자. 어려운 부분이 있다면 Copilot의 제안을 참고하여 빈칸을 채워보자.


```dart
// 1) Animal 클래스를 정의하고 breathe() 메서드를 만들어보자.
class Animal {
  // breathe() 메서드를 정의
  //void breathe() {
    // ...
  //}
  
}

// 2) Dog 클래스를 Animal로부터 상속받고, breathe()를 override 해보자.
class Dog extends Animal {
  // @override 붙이고, 자식만의 숨쉬기 구현
  //...
}

// 3) Cat 클래스도 만들어서 breathe()를 override 해보자.
class Cat extends Animal {
  // @override 붙이고, 자식만의 숨쉬기 구현
  //...
}

// 4) Animal을 매개변수로 받아 처리를 돕는, AnimalBreatheHelper 클래스를 작성해보자.
class AnimalBreatheHelper {
  // 부모 타입인 Animal 타입을 매개변수로 받도록 하고,
  // 전달받은 animal의 breathe()를 호출하는 메서드
  //...
}

// 5) main() 함수에서 Dog와 Cat 객체를 생성하고, AnimalBreatheHelper를 통해 breathe() 메서드를 호출해보자.
void main() {
  // Dog, Cat 객체 생성
  //...
  // AnimalBreatheHelper 클래스 생성
  //...

  // 각 동물을 넣어 breathe() 호출
  // animalBreatheHelper.breathe(dog);
  // animalBreatheHelper.breathe(cat);

  // 5) 업캐스팅: Dog를 Animal 타입으로 선언해보세요.
  // Animal dogAnimal = ...;
  // dogAnimal.breathe();

  // 6) 다운캐스팅: Animal을 Dog로 되돌리려면 어떻게 할까요?
  // if (dogAnimal is Dog) { //반드시 Dog 타입인지 확인
  //   Dog realDog = dogAnimal as Dog;
  //   realDog.breathe(); // Dog의 breathe()가 호출됩니다.
  // }

}
```